<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>RoomCast</title>
  <style>
    :root {
      color-scheme: dark;
      font-family: "Inter", system-ui, -apple-system, sans-serif;
      background: #0b1020;
      color: #e2e8f0;
      --accent: #22c55e;
      --accent-dark: #16a34a;
      --panel: rgba(15,23,42,0.92);
    }
    * { box-sizing: border-box; }
    body { margin: 0; padding: 0; background: radial-gradient(circle at 20% 20%, rgba(34,197,94,0.08), transparent 30%), radial-gradient(circle at 80% 0%, rgba(59,130,246,0.08), transparent 25%), #0b1020; min-height: 100vh; position: relative; overflow-x: hidden; }
    body.use-cover-art-background { background: #020617; }
    #cover-art-backdrop { position: fixed; inset: -40px; background: #020617; background-size: cover; background-position: center; filter: blur(40px); opacity: 0; transition: opacity 0.35s ease; z-index: 0; pointer-events: none; }
    body.use-cover-art-background #cover-art-backdrop { opacity: 1; }
    .shell { max-width: 960px; margin: 0 auto; padding: 16px 16px 220px; position: relative; z-index: 1; }
    header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; }
    h1 { margin: 0; font-size: 22px; letter-spacing: -0.4px; }
    .icon-btn { background: rgba(255,255,255,0.07); color: #e2e8f0; border: 1px solid rgba(255,255,255,0.12); padding: 8px 10px; border-radius: 12px; cursor: pointer; font-weight: 700; min-width: 44px; width: auto; display: inline-flex; align-items: center; justify-content: center; gap: 4px; }
    .icon-btn svg { width: 18px; height: 18px; display: block; }
    .panel { background: rgba(255, 255, 255, 0.04); border: 1px solid rgba(255, 255, 255, 0.08); border-radius: 16px; padding: 16px; margin-bottom: 16px; box-shadow: 0 14px 36px rgba(0,0,0,0.3); }
    .panel-heading { display: flex; align-items: center; justify-content: space-between; gap: 12px; margin-bottom: 12px; }
    .panel-heading .section-title { margin: 0; }
    .section-title { font-size: 14px; text-transform: uppercase; letter-spacing: 1px; color: #94a3b8; margin: 0 0 10px; }
    .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap: 12px; }
    label { display: block; font-size: 13px; color: #cbd5e1; margin-bottom: 6px; }
    input, select, textarea { width: 100%; border-radius: 12px; border: 1px solid rgba(255,255,255,0.12); background: rgba(255,255,255,0.06); color: #e2e8f0; padding: 10px 12px; font-size: 14px; }
    input[type=range] { -webkit-appearance: none; appearance: none; padding: 0; border: none; background: rgba(255,255,255,0.12); height: 4px; border-radius: 999px; }
    input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 14px; height: 14px; border-radius: 50%; background: var(--accent); border: none; box-shadow: 0 0 12px rgba(34,197,94,0.35); cursor: pointer; }
    input[type=range]::-moz-range-thumb { width: 14px; height: 14px; border-radius: 50%; background: var(--accent); border: none; box-shadow: 0 0 12px rgba(34,197,94,0.35); cursor: pointer; }
    select {
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
      background-color: rgba(15,23,42,0.65);
      border: 1px solid rgba(148,163,184,0.4);
      padding-right: 40px;
      background-image: url("data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%2024%2024'%20fill='%23e2e8f0'%3E%3Cpath%20d='M6%209l6%206%206-6'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 12px center;
      background-size: 14px;
      cursor: pointer;
      transition: border-color 0.15s ease, box-shadow 0.15s ease;
    }
    select:focus {
      border-color: rgba(34,197,94,0.6);
      box-shadow: 0 0 0 2px rgba(34,197,94,0.25);
      outline: none;
    }
    select::-ms-expand { display: none; }
    textarea { min-height: 64px; }
    .muted { opacity: 0.7; }
    .label { font-size: 13px; color: #cbd5e1; margin-top: 6px; }
    .toast { position: fixed; top: 16px; left: 50%; transform: translate(-50%, -8px); min-width: 240px; max-width: 90vw; z-index: 1000; transition: opacity 0.2s ease, transform 0.2s ease; }
    .error { background: #fecdd3; color: #7f1d1d; padding: 12px; border-radius: 12px; box-shadow: 0 15px 30px rgba(0,0,0,0.35); }
    .success { background: rgba(34,197,94,0.14); color: #bbf7d0; padding: 12px; border-radius: 12px; box-shadow: 0 15px 30px rgba(0,0,0,0.35); }
    input[type=range] { accent-color: #22c55e; }
    button { background: linear-gradient(135deg, #22c55e, #16a34a); color: #0b1020; border: none; padding: 10px 14px; border-radius: 12px; cursor: pointer; font-weight: 700; width: 100%; transition: transform 0.08s ease, filter 0.12s ease; }
    button:active { transform: translateY(1px) scale(0.99); filter: brightness(0.95); }
    .small-btn { width: auto; padding: 8px 12px; }
    .icon-only-btn { width: 42px; height: 42px; border-radius: 999px; padding: 0; display: inline-flex; align-items: center; justify-content: center; border: 1px solid rgba(255,255,255,0.14); background: rgba(255,255,255,0.08); color: #f8fafc; }
    .header-actions { display: flex; gap: 8px; align-items: center; }
    .add-node-container { position: relative; }
    .add-node-button { display: inline-flex; align-items: center; gap: 6px; }
    .add-node-menu { position: absolute; top: calc(100% + 6px); right: 0; background: rgba(15,23,42,0.95); border: 1px solid rgba(255,255,255,0.1); border-radius: 12px; padding: 6px; min-width: 190px; box-shadow: 0 12px 30px rgba(0,0,0,0.45); display: none; flex-direction: column; z-index: 40; }
    .add-node-container.is-open .add-node-menu { display: flex; }
    .add-node-menu button { background: transparent; border: none; color: #e2e8f0; width: 100%; text-align: left; padding: 10px; border-radius: 8px; font-weight: 600; }
    .add-node-menu button:hover { background: rgba(34,197,94,0.15); color: #bbf7d0; }
    .node-header { display: flex; justify-content: space-between; align-items: center; gap: 8px; }
    .node-gear { position: relative; display: flex; gap: 8px; align-items: center; }
    .node-icon-btn { width: 48px; height: 48px; border: none; background: transparent; border-radius: 50%; display: inline-flex; align-items: center; justify-content: center; color: #e2e8f0; cursor: pointer; transition: color 0.15s ease, transform 0.1s ease; font-size: 22px; }
    .node-icon-btn svg { width: 28px; height: 28px; display: block; }
    .node-icon-btn:focus-visible { outline: 2px solid rgba(34,197,94,0.6); outline-offset: 2px; }
    .node-icon-btn:hover:not(:disabled) { color: #a5f3fc; }
    .node-icon-btn:active:not(:disabled) { transform: scale(0.96); }
    .node-icon-btn:disabled { opacity: 0.35; cursor: default; }
    .node-actions { display: flex; gap: 8px; align-items: center; margin-top: 8px; }
    .node-mute-btn { width: 42px; height: 42px; border-radius: 12px; padding: 0; display: inline-flex; align-items: center; justify-content: center; border: 1px solid rgba(255,255,255,0.14); background: rgba(15,23,42,0.8); color: #e2e8f0; }
    .node-mute-btn svg { width: 18px; height: 18px; }
    .node-status { font-size: 12px; color: #cbd5e1; margin-top: 6px; display: flex; align-items: center; gap: 10px; }
    .status-pill { padding: 2px 8px; border-radius: 999px; font-size: 11px; letter-spacing: 0.4px; text-transform: uppercase; }
    .status-pill.ok { background: rgba(34,197,94,0.18); color: #bbf7d0; }
    .status-pill.warn { background: rgba(249,115,22,0.18); color: #fed7aa; }
    .eq-block { margin-top: 10px; }
    .eq-band-list { max-height: 70vh; overflow-y: auto; margin-top: 12px; }
    .eq-band-list.is-fader-view { max-height: none; overflow-y: visible; padding-bottom: 8px; }
    .eq-band-row { display: grid; grid-template-columns: 56px 1fr 1fr 1fr; gap: 12px; padding: 8px 0; border-bottom: 1px solid rgba(255,255,255,0.05); }
    .eq-band-row:last-child { border-bottom: none; }
    .eq-band-label { font-size: 12px; color: rgba(255,255,255,0.5); align-self: center; }
    .eq-band-cell label { font-size: 11px; text-transform: uppercase; display: block; margin-bottom: 4px; color: rgba(255,255,255,0.5); }
    .eq-band-cell input[type="number"] { width: 100%; margin-bottom: 4px; }
    .eq-band-cell input[type="range"] { width: 100%; }
    .eq-toolbar { display: flex; flex-wrap: wrap; gap: 10px; align-items: center; margin-bottom: 12px; }
    .eq-toolbar select, .eq-toolbar button { flex: 0 0 auto; }
    .eq-skin-select { min-width: 180px; }
    .eq-fader-view { --eq-fader-width: 86px; display: flex; gap: 18px; overflow-x: auto; overflow-y: hidden; padding: 12px 6px 8px; scrollbar-width: thin; min-height: 320px; }
    .eq-fader-view::-webkit-scrollbar { height: 8px; }
    .eq-fader-view::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 999px; }
    .eq-fader { flex: 0 0 var(--eq-fader-width); min-width: var(--eq-fader-width); background: rgba(4,9,20,0.82); border: 1px solid rgba(255,255,255,0.08); border-radius: 18px; padding: 12px 10px 14px; text-align: center; box-shadow: inset 0 12px 34px rgba(0,0,0,0.5); display: flex; flex-direction: column; gap: 12px; min-height: 300px; }
    .eq-fader-meta { font-size: 11px; text-transform: uppercase; letter-spacing: 0.8px; color: rgba(255,255,255,0.6); display: flex; flex-direction: column; gap: 2px; }
    .eq-fader-meta span:first-child { font-weight: 700; color: #f8fafc; }
    .eq-fader-gain { font-size: 13px; font-weight: 600; color: #f8fafc; }
    .eq-fader-slider-wrap { flex: 1; display: flex; justify-content: center; align-items: center; position: relative; padding: 6px 0 10px; cursor: ns-resize; touch-action: none; overflow: visible; }
    .eq-fader-slider-wrap.is-dragging { cursor: grabbing; }
    .eq-fader-track { position: absolute; width: 10px; top: 6px; bottom: 10px; border-radius: 999px; background: linear-gradient(180deg, rgba(255,255,255,0.4), rgba(6,12,26,0.95)); box-shadow: inset 0 0 0 1px rgba(255,255,255,0.08); z-index: 1; }
    .eq-fader-track::before { content: ''; position: absolute; left: 50%; top: 50%; width: 20px; height: 2px; background: rgba(248,250,252,0.35); transform: translate(-50%, -50%); }
    .eq-fader-slider { position: absolute; inset: 0; width: 100%; height: 100%; margin: 0; padding: 0; opacity: 0; pointer-events: none; background: transparent; border: none; }
    .eq-fader-slider { -webkit-appearance: slider-vertical; appearance: slider-vertical; writing-mode: bt-lr; }
    .eq-fader-slider:focus-visible + .eq-fader-thumb { box-shadow: 0 0 0 2px rgba(34,197,94,0.45); }
    .eq-fader-thumb { position: absolute; left: 50%; top: var(--fader-thumb-top, 50%); transform: translate(-50%, -50%); width: 34px; height: 28px; border-radius: 8px; background: linear-gradient(165deg, #f8fafc 0%, #d8dee9 40%, #9ca3af 100%); border: 2px solid rgba(8,14,28,0.9); box-shadow: 0 6px 14px rgba(0,0,0,0.45); z-index: 2; pointer-events: none; }
    @media (orientation: landscape) {
      .eq-fader { --eq-fader-width: 110px; }
    }
    .settings-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.6); display: none; align-items: flex-start; justify-content: center; overflow-y: auto; padding: 24px 12px; z-index: 200; }
    .settings-card { background: #0f172a; border: 1px solid rgba(255,255,255,0.08); border-radius: 18px; padding: 16px; width: min(960px, 95vw); box-shadow: 0 18px 40px rgba(0,0,0,0.35); }
    .settings-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; }
    .spinner { width: 18px; height: 18px; border: 3px solid rgba(255,255,255,0.2); border-top-color: #22c55e; border-radius: 50%; animation: spin 0.8s linear infinite; display: inline-block; vertical-align: middle; }
    @keyframes spin { to { transform: rotate(360deg); } }
    .node-settings-content { display: flex; flex-direction: column; gap: 12px; }
    .node-meta-row { margin-bottom: 10px; }
    .node-meta-row:last-child { margin-bottom: 0; }
    .node-meta-row .label { margin-top: 0; }
    .node-meta-value { font-size: 14px; color: #e2e8f0; word-break: break-word; }
    .modal-actions { display: flex; flex-direction: column; gap: 8px; margin-top: 8px; }
    .modal-actions button { width: 100%; }
    .nodes-section { margin: 8px 0 24px; }
    .nodes-section #nodes { margin-top: 12px; }
    .collapsible-panel { padding: 0; overflow: hidden; }
    .collapsible-header { width: 100%; padding: 18px 20px; background: transparent; border: none; color: #e2e8f0; display: flex; justify-content: space-between; align-items: center; gap: 12px; cursor: pointer; font-size: 14px; letter-spacing: 0.8px; text-transform: uppercase; }
    .collapsible-header .section-title { margin: 0; }
    .collapsible-header:focus-visible { outline: 2px solid rgba(34,197,94,0.6); outline-offset: 2px; }
    .collapsible-icon { font-size: 18px; transition: transform 0.2s ease; color: #94a3b8; }
    .collapsible-panel[data-open="true"] .collapsible-icon { transform: rotate(180deg); }
    .collapsible-content { display: none; padding: 0 20px 20px 20px; border-top: 1px solid rgba(255,255,255,0.08); }
    .collapsible-panel[data-open="true"] .collapsible-content { display: block; }
    #player-panel { position: fixed; bottom: 0; left: 0; right: 0; background: rgba(6,10,20,0.25); backdrop-filter: blur(28px); border-top: 1px solid rgba(148,163,184,0.2); box-shadow: 0 -24px 60px rgba(0,0,0,0.35); padding: 14px 18px 18px; display: flex; flex-direction: column; gap: 14px; z-index: 50; }
    .player-top { display: flex; flex-wrap: nowrap; gap: 16px; justify-content: space-between; align-items: center; }
    .player-meta { display: flex; align-items: center; gap: 12px; flex: 1 1 auto; min-width: 0; }
    #player-art { width: 44px; height: 44px; border-radius: 8px; object-fit: cover; background: rgba(255,255,255,0.05); box-shadow: 0 6px 16px rgba(0,0,0,0.45); }
    .player-text { display: flex; flex-direction: column; gap: 2px; }
    .player-title { font-weight: 600; font-size: 15px; color: #f8fafc; letter-spacing: 0.1px; }
    .player-artist { font-size: 12px; color: #94a3b8; letter-spacing: 0.3px; }
    .player-volume-inline { position: relative; flex: 0 0 auto; display: inline-flex; align-items: center; }
    .player-volume-toggle { position: relative; }
    .player-volume-toggle svg { width: 24px; height: 24px; display: block; }
    .player-progress { display: flex; flex-direction: column; gap: 6px; }
    .player-progress input[type=range] { width: 100%; height: 4px; }
    .player-progress input[type=range]::-webkit-slider-runnable-track { height: 4px; border-radius: 999px; background: rgba(255,255,255,0.08); }
    .player-progress input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; margin-top: -6px; width: 12px; height: 12px; border-radius: 50%; background: var(--accent); border: 2px solid rgba(11,16,32,0.9); box-shadow: 0 0 15px rgba(34,197,94,0.4); }
    .player-progress input[type=range]::-moz-range-track { height: 4px; border-radius: 999px; background: rgba(255,255,255,0.08); }
    .player-progress input[type=range]::-moz-range-thumb { width: 12px; height: 12px; border-radius: 50%; background: var(--accent); border: 2px solid rgba(11,16,32,0.9); box-shadow: 0 0 15px rgba(34,197,94,0.4); }
    .player-time-row { display: flex; justify-content: space-between; font-size: 11px; color: #cbd5e1; }
    .player-controls { display: flex; justify-content: space-between; align-items: center; gap: 14px; }
    .player-icon-btn { width: 40px; height: 40px; border-radius: 999px; padding: 0; display: inline-flex; align-items: center; justify-content: center; border: 1px solid rgba(255,255,255,0.12); background: rgba(255,255,255,0.08); color: #f8fafc; box-shadow: 0 6px 14px rgba(0,0,0,0.4); cursor: pointer; position: relative; transition: border-color 0.15s ease, color 0.15s ease, background 0.15s ease; }
    .player-icon-btn svg { width: 24px; height: 24px; display: block; }
    .gear-btn { font-size: 20px; padding: 10px 12px; min-width: 44px; }
    .player-icon-btn.is-active { border-color: var(--accent); color: var(--accent); box-shadow: 0 0 20px rgba(34,197,94,0.35); }
    .player-icon-btn.play { width: 48px; height: 48px; background: linear-gradient(135deg, var(--accent), var(--accent-dark)); border: none; color: #041109; box-shadow: 0 10px 22px rgba(34,197,94,0.35); }
    .player-icon-btn:disabled { opacity: 0.35; cursor: default; box-shadow: none; }
    .player-icon-btn.repeat-track::after { content: '1'; position: absolute; top: 6px; right: 8px; font-size: 10px; font-weight: 700; color: currentColor; }
    .player-volume-slider { position: absolute; right: 50%; bottom: calc(100% + 16px); transform: translateX(50%) translateY(8px); opacity: 0; pointer-events: none; transition: opacity 0.18s ease, transform 0.18s ease; display: flex; justify-content: center; }
    .player-volume-inline.is-open .player-volume-slider { opacity: 1; pointer-events: auto; transform: translateX(50%) translateY(0); }
    .player-volume-inline input[type=range] { appearance: none; -webkit-appearance: slider-vertical; width: 6px; height: 150px; border-radius: 999px; background: transparent; writing-mode: bt-lr; }
    .player-volume-inline input[type=range]::-webkit-slider-runnable-track { width: 6px; height: 100%; border-radius: 999px; background: rgba(255,255,255,0.15); }
    .player-volume-inline input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 12px; height: 12px; border-radius: 50%; background: var(--accent); border: none; margin-top: -4px; }
    .player-volume-inline input[type=range]::-moz-range-track { width: 6px; height: 100%; border-radius: 999px; background: rgba(255,255,255,0.15); }
    .player-volume-inline input[type=range]::-moz-range-thumb { width: 12px; height: 12px; border-radius: 50%; background: var(--accent); border: none; }
    @media (min-width: 720px) {
      #player-panel { padding: 16px 32px 22px; }
      .player-meta { flex: 1 1 auto; }
      .player-volume-inline { flex: 0 0 auto; }
      .player-controls { max-width: 420px; margin: 0 auto; }
    }
    @media (max-width: 640px) {
      header { flex-direction: row; }
      .node-actions { flex-wrap: wrap; }
    }
  </style>
</head>
<body>
  <div id="cover-art-backdrop" aria-hidden="true"></div>
  <div class="shell">
    <header>
      <h1>RoomCast</h1>
      <div class="header-actions">
        <div class="add-node-container" data-add-node-container>
          <button id="add-node-button" class="icon-btn add-node-button" aria-haspopup="true" aria-expanded="false">Add node ▾</button>
          <div id="add-node-menu" class="add-node-menu" role="menu" aria-hidden="true">
            <button id="add-hardware-node" type="button" role="menuitem">Add hardware node</button>
            <button id="create-web-node" type="button" role="menuitem">Create web node</button>
          </div>
        </div>
        <button id="open-settings" class="icon-btn gear-btn" aria-label="Settings">⚙︎</button>
      </div>
    </header>

    <div id="error" class="toast error" style="display:none; opacity:0;"></div>
    <div id="success" class="toast success" style="display:none; opacity:0;"></div>

    <div class="nodes-section">
      <div class="section-title">Nodes</div>
      <div id="nodes"></div>
    </div>

  </div>

  <div id="player-panel">
    <div class="player-top">
      <div class="player-meta">
        <img id="player-art" src="" alt="" style="display:none;">
        <div class="player-text">
          <div id="player-title" class="player-title">Player unavailable</div>
          <div id="player-artist" class="player-artist">—</div>
        </div>
      </div>
      <div class="player-volume-inline" id="player-volume-inline">
        <button class="player-volume-toggle player-icon-btn" id="player-volume-toggle" type="button" aria-label="Adjust master volume" aria-expanded="false"></button>
        <div class="player-volume-slider" aria-hidden="true">
          <input type="range" id="master-volume" min="0" max="100" value="75" aria-label="Master volume">
        </div>
      </div>
    </div>
    <div class="player-progress">
      <input type="range" id="player-seek" min="0" max="100" value="0">
      <div class="player-time-row">
        <span id="player-time-current">0:00</span>
        <span id="player-time-total">0:00</span>
      </div>
    </div>
    <div class="player-controls">
      <button class="player-icon-btn" id="player-shuffle" aria-label="Shuffle"></button>
      <button class="player-icon-btn" id="player-prev" aria-label="Previous"></button>
      <button class="player-icon-btn play" id="player-play" aria-label="Play/Pause"></button>
      <button class="player-icon-btn" id="player-next" aria-label="Next"></button>
      <button class="player-icon-btn" id="player-repeat" aria-label="Repeat"></button>
    </div>
  </div>

  <div id="settings-overlay" class="settings-overlay">
    <div class="settings-card">
      <div class="settings-header">
        <div class="section-title" style="margin:0;">Settings</div>
        <button id="close-settings" class="icon-btn">✕</button>
      </div>
      <div class="panel collapsible-panel" data-collapsible>
        <button class="collapsible-header" type="button" aria-expanded="false">
          <span class="section-title" style="margin:0;">General</span>
          <span class="collapsible-icon" aria-hidden="true">▾</span>
        </button>
        <div class="collapsible-content" aria-hidden="true">
          <div style="display:flex; align-items:center; justify-content:space-between; gap:12px;">
            <div>
              <div class="label" style="margin:0;">Use cover art as background</div>
              <div class="muted" style="font-size:12px;">Applies the current track art as a blurred backdrop across the app.</div>
            </div>
            <input id="cover-art-background" type="checkbox" style="width:auto;" checked>
          </div>
        </div>
      </div>

      <div class="panel collapsible-panel" data-collapsible>
        <button class="collapsible-header" type="button" aria-expanded="false">
          <span class="section-title" style="margin:0;">Spotify setup</span>
          <span class="collapsible-icon" aria-hidden="true">▾</span>
        </button>
        <div class="collapsible-content" aria-hidden="true">
          <div class="muted" id="librespot-status" style="margin-bottom:8px;">Status: unknown</div>
          <div class="grid">
            <div>
              <label>Spotify client ID</label>
              <input id="sp-client-id" placeholder="client id">
            </div>
            <div>
              <label>Spotify client secret</label>
              <input id="sp-client-secret" type="password" placeholder="client secret">
            </div>
            <div>
              <label>Redirect URI</label>
              <input id="sp-redirect" placeholder="http://localhost:8000/api/spotify/callback">
            </div>
            <div>
              <label>Device name</label>
              <input id="sp-name" placeholder="RoomCast">
            </div>
            <div>
              <label>Bitrate</label>
              <select id="sp-bitrate">
                <option value="96">96 kbps</option>
                <option value="160">160 kbps</option>
                <option value="320" selected>320 kbps</option>
              </select>
            </div>
            <div>
              <label>Initial volume</label>
              <input id="sp-initvol" type="range" min="0" max="100" value="75">
            </div>
            <div style="display:flex; align-items:center; gap:6px;">
              <label style="margin:0;">Volume normalisation</label>
              <input id="sp-normalise" type="checkbox" style="width:auto;">
            </div>
        </div>
          <div style="margin-top:12px;">
            <button id="save-spotify">Save Spotify config</button>
            <div id="spotify-spinner" style="display:none; margin-top:8px;"><span class="spinner"></span> <span class="muted">Saving & restarting…</span></div>
            <div style="margin-top:8px;">
            <button class="small-btn" id="spotify-auth">Link Spotify account</button>
            <button class="small-btn" id="spotify-dashboard">Open Spotify developer dashboard</button>
            <div id="spotify-link-status" class="status-pill warn" style="margin-top:6px;">Account link status: unknown</div>
            <div class="muted" style="font-size:12px;">Create Client ID/Secret in the dashboard, save them here, then click “Link Spotify account”. Password sign-ins are no longer supported.</div>
            </div>
          </div>
        </div>
      </div>

      <div class="panel collapsible-panel" data-collapsible>
        <button class="collapsible-header" type="button" aria-expanded="false">
          <span class="section-title" style="margin:0;">Snapcast clients (view)</span>
          <span class="collapsible-icon" aria-hidden="true">▾</span>
        </button>
        <div class="collapsible-content" aria-hidden="true">
          <div id="clients-settings"></div>
        </div>
      </div>

    </div>
  </div>

  <div id="discover-overlay" class="settings-overlay">
    <div class="settings-card">
      <div class="settings-header">
        <div class="section-title" style="margin:0;">Discover nodes</div>
        <button id="close-discover" class="icon-btn">✕</button>
      </div>
      <div style="display:flex; gap:12px; align-items:center; justify-content:space-between; flex-wrap:wrap; margin-bottom:8px;">
        <div class="muted" style="flex:1; min-width:200px;">Scans all available networks and streams results live.</div>
        <button id="start-discover" class="small-btn" style="min-width:120px;">Scan</button>
      </div>
      <div id="discover-spinner" style="margin-bottom:8px; display:none;"><span class="spinner"></span> <span class="muted">Scanning...</span></div>
      <div id="discover-status" class="muted">Ready to scan.</div>
      <div id="discover-list"></div>
    </div>
  </div>

  <script>
    const nodesEl = document.getElementById('nodes');
    const clientsSettingsEl = document.getElementById('clients-settings');
    const errorEl = document.getElementById('error');
    const successEl = document.getElementById('success');
    const addNodeContainer = document.querySelector('[data-add-node-container]');
    const addNodeToggle = document.getElementById('add-node-button');
    const addNodeMenu = document.getElementById('add-node-menu');
    const addHardwareNodeBtn = document.getElementById('add-hardware-node');
    const createWebNodeBtn = document.getElementById('create-web-node');
    const saveSpotifyBtn = document.getElementById('save-spotify');
    const spClientId = document.getElementById('sp-client-id');
    const spClientSecret = document.getElementById('sp-client-secret');
    const spRedirect = document.getElementById('sp-redirect');
    const spName = document.getElementById('sp-name');
    const spBitrate = document.getElementById('sp-bitrate');
    const spInitVol = document.getElementById('sp-initvol');
    setRangeProgress(spInitVol, spInitVol?.value || 0, spInitVol?.max || 100);
    const spNormalise = document.getElementById('sp-normalise');
    const nodeName = document.getElementById('node-name');
    const nodeUrl = document.getElementById('node-url');
    const librespotStatus = document.getElementById('librespot-status');
    const settingsOverlay = document.getElementById('settings-overlay');
    const openSettingsBtn = document.getElementById('open-settings');
    const closeSettingsBtn = document.getElementById('close-settings');
    const spotifySpinner = document.getElementById('spotify-spinner');
    const discoverOverlay = document.getElementById('discover-overlay');
    const closeDiscoverBtn = document.getElementById('close-discover');
    const discoverSpinner = document.getElementById('discover-spinner');
    const discoverStatus = document.getElementById('discover-status');
    const discoverList = document.getElementById('discover-list');
    const startDiscoverBtn = document.getElementById('start-discover');
    const masterVolume = document.getElementById('master-volume');
    setRangeProgress(masterVolume, masterVolume?.value || 0, masterVolume?.max || 100);
    const playerVolumeInline = document.getElementById('player-volume-inline');
    const playerVolumeToggle = document.getElementById('player-volume-toggle');
    const playerPanel = document.getElementById('player-panel');
    const playerShuffleBtn = document.getElementById('player-shuffle');
    const playerPrev = document.getElementById('player-prev');
    const playerPlay = document.getElementById('player-play');
    const playerNext = document.getElementById('player-next');
    const playerRepeatBtn = document.getElementById('player-repeat');
    const playerSeek = document.getElementById('player-seek');
    setRangeProgress(playerSeek, playerSeek?.value || 0, playerSeek?.max || 1);
    const playerTimeCurrent = document.getElementById('player-time-current');
    const playerTimeTotal = document.getElementById('player-time-total');
    const playerArt = document.getElementById('player-art');
    const playerTitle = document.getElementById('player-title');
    const playerArtist = document.getElementById('player-artist');
    const coverArtBackdrop = document.getElementById('cover-art-backdrop');
    const coverArtBackgroundToggle = document.getElementById('cover-art-background');
    const collapsiblePanels = Array.from(document.querySelectorAll('[data-collapsible]'));
    let playerStatus = null;
    let activeDeviceId = null;
    let playerTick = null;
    let discoverAbortController = null;
    let discoverResultsCount = 0;
    let nodeSettingsModal = null;
    let nodeSettingsContent = null;
    let nodeSettingsTitle = null;
    let nodeSettingsNodeId = null;
    let useCoverArtBackground = true;
    let lastCoverArtUrl = null;



    function initializePlayerButtons() {
      if (playerVolumeToggle) playerVolumeToggle.innerHTML = ICON_VOLUME_ON;
      if (playerShuffleBtn) {
        playerShuffleBtn.innerHTML = ICON_SHUFFLE;
        setShuffleActive(false);
      }
      if (playerPrev) playerPrev.innerHTML = ICON_PREV;
      if (playerNext) playerNext.innerHTML = ICON_NEXT;
      if (playerRepeatBtn) {
        playerRepeatBtn.innerHTML = ICON_REPEAT;
        setRepeatMode('off');
      }
      setPlayButtonIcon(false);
    }

    function clearMessages() {
      errorEl.style.display = 'none';
      successEl.style.display = 'none';
    }

    const toastQueue = [];
    let toastActive = false;

    function showToast(el, msg, timeout = 3500) {
      el.innerText = msg;
      el.style.display = 'block';
      el.style.opacity = '1';
      el.style.transform = 'translateY(0)';
      setTimeout(() => {
        el.style.opacity = '0';
        el.style.transform = 'translateY(-8px)';
        setTimeout(() => {
          el.style.display = 'none';
        }, 200);
      }, timeout);
    }

    function enqueueToast(el, msg, timeout) {
      toastQueue.push({ el, msg, timeout });
      if (!toastActive) runToastQueue();
    }

    function runToastQueue() {
      if (!toastQueue.length) {
        toastActive = false;
        return;
      }
      toastActive = true;
      const { el, msg, timeout } = toastQueue.shift();
      showToast(el, msg, timeout);
      setTimeout(runToastQueue, (timeout || 3500) + 250);
    }

    function showError(msg) {
      enqueueToast(errorEl, msg, 4500);
    }

    function showSuccess(msg) {
      enqueueToast(successEl, msg, 3000);
    }

    function normalizeNodeUrl(value) {
      let url = (value || '').trim();
      if (!url) return '';
      if (url.startsWith('browser:')) return url.replace(/\/+$/, '');
      if (!url.includes('://')) url = `http://${url}`;
      return url.replace(/\/+$/, '');
    }

    function formatTimestamp(seconds) {
      if (typeof seconds !== 'number' || Number.isNaN(seconds) || seconds <= 0) return '';
      const date = new Date(seconds * 1000);
      if (Number.isNaN(date.getTime())) return '';
      return date.toLocaleString();
    }

    function describeNodeHost(url) {
      if (!url) return '';
      if (url.startsWith('browser:')) return 'Browser session';
      try {
        const parsed = new URL(url);
        return parsed.hostname || url;
      } catch (_) {
        return url;
      }
    }

    function findNodeByFingerprint(fingerprint) {
      if (!fingerprint) return null;
      return nodesCache.find(n => n.fingerprint && n.fingerprint === fingerprint) || null;
    }

    async function ensureOk(res, fallback) {
      if (res.ok) return res;
      let detail = fallback || `HTTP ${res.status}`;
      try {
        const text = await res.text();
        if (text) {
          try {
            const parsed = JSON.parse(text);
            if (parsed?.detail) detail = parsed.detail;
            else if (parsed?.message) detail = parsed.message;
            else detail = text;
          } catch (_) {
            detail = text;
          }
        }
      } catch (_) {
        /* ignore body parse errors */
      }
      throw new Error(detail);
    }

    function describePan(value) {
      const num = typeof value === 'number' ? value : Number(value);
      if (Number.isNaN(num) || Math.abs(num) < 0.01) return 'Center';
      const pct = Math.round(Math.abs(num) * 100);
      return num > 0 ? `Right ${pct}%` : `Left ${pct}%`;
    }

    function getActiveDeviceId() {
      if (playerStatus?.device?.id) return playerStatus.device.id;
      if (activeDeviceId) return activeDeviceId;
      return null;
    }

    function hasAgentUpdate(node) {
      if (!node) return false;
      if (node.update_available === true) return true;
      if (node.update_available === false) return false;
      const latest = node.latest_agent_version;
      const current = node.agent_version;
      if (latest && current) return latest !== current;
      return !!latest && !current;
    }

    function setRangeProgress(el, value, maxOverride) {
      if (!el) return;
      const min = Number(el.min ?? 0);
      const rawMax = maxOverride !== undefined ? Number(maxOverride) : Number(el.max);
      const safeMin = Number.isFinite(min) ? min : 0;
      const safeMax = Number.isFinite(rawMax) ? rawMax : safeMin + 1;
      const span = Math.max(0.0001, safeMax - safeMin);
      const rawValue = value !== undefined ? Number(value) : Number(el.value);
      const safeValue = Number.isFinite(rawValue) ? rawValue : safeMin;
      const ratio = (safeValue - safeMin) / span;
      const percent = Math.max(0, Math.min(100, ratio * 100));
      el.style.background = `linear-gradient(90deg, var(--accent) 0%, var(--accent) ${percent}%, rgba(255,255,255,0.12) ${percent}%, rgba(255,255,255,0.12) 100%)`;
    }

    function setPlayButtonIcon(playing) {
      if (!playerPlay) return;
      playerPlay.innerHTML = playing ? ICON_PAUSE : ICON_PLAY;
      playerPlay.setAttribute('aria-label', playing ? 'Pause' : 'Play');
    }

    function setShuffleActive(active) {
      if (!playerShuffleBtn) return;
      const next = !!active;
      playerShuffleBtn.classList.toggle('is-active', next);
      playerShuffleBtn.setAttribute('aria-pressed', next ? 'true' : 'false');
      playerShuffleBtn.setAttribute('aria-label', next ? 'Disable shuffle' : 'Enable shuffle');
    }

    function setRepeatMode(mode) {
      if (!playerRepeatBtn) return;
      const normalized = mode === 'context' || mode === 'track' ? mode : 'off';
      playerRepeatBtn.dataset.mode = normalized;
      playerRepeatBtn.classList.toggle('is-active', normalized !== 'off');
      playerRepeatBtn.classList.toggle('repeat-track', normalized === 'track');
      playerRepeatBtn.setAttribute('aria-pressed', normalized !== 'off' ? 'true' : 'false');
      const label = normalized === 'track'
        ? 'Repeat current track'
        : normalized === 'context'
          ? 'Repeat queue'
          : 'Enable repeat';
      playerRepeatBtn.setAttribute('aria-label', label);
    }

    function setVolumeSliderOpen(open) {
      if (!playerVolumeInline || !playerVolumeToggle) return;
      const next = !!open;
      playerVolumeInline.classList.toggle('is-open', next);
      playerVolumeToggle.setAttribute('aria-expanded', next ? 'true' : 'false');
      const slider = playerVolumeInline.querySelector('.player-volume-slider');
      if (slider) slider.setAttribute('aria-hidden', next ? 'false' : 'true');
      if (next && masterVolume) {
        setTimeout(() => masterVolume.focus({ preventScroll: true }), 0);
      }
    }

    function setAddNodeMenuOpen(open) {
      if (!addNodeContainer || !addNodeMenu || !addNodeToggle) return;
      const next = !!open;
      addNodeContainer.classList.toggle('is-open', next);
      addNodeMenu.setAttribute('aria-hidden', next ? 'false' : 'true');
      addNodeToggle.setAttribute('aria-expanded', next ? 'true' : 'false');
    }

    function setCollapsiblePanelState(panel, open) {
      if (!panel) return;
      const trigger = panel.querySelector('.collapsible-header');
      const content = panel.querySelector('.collapsible-content');
      const next = !!open;
      panel.dataset.open = next ? 'true' : 'false';
      if (trigger) trigger.setAttribute('aria-expanded', next ? 'true' : 'false');
      if (content) content.setAttribute('aria-hidden', next ? 'false' : 'true');
    }

    function initCollapsiblePanels() {
      collapsiblePanels.forEach(panel => {
        const trigger = panel.querySelector('.collapsible-header');
        if (!trigger) return;
        trigger.addEventListener('click', () => {
          const isOpen = panel.dataset.open === 'true';
          setCollapsiblePanelState(panel, !isOpen);
        });
        setCollapsiblePanelState(panel, false);
      });
    }

    function collapseAllPanels() {
      collapsiblePanels.forEach(panel => setCollapsiblePanelState(panel, false));
    }

    function applyCoverArtBackground() {
      if (!coverArtBackdrop) return;
      if (useCoverArtBackground && lastCoverArtUrl) {
        const safeUrl = lastCoverArtUrl.replace(/"/g, '\"');
        coverArtBackdrop.style.backgroundImage = `${COVER_ART_BACKDROP_OVERLAY}, url("${safeUrl}")`;
      } else {
        coverArtBackdrop.style.backgroundImage = '';
      }
      document.body.classList.toggle('use-cover-art-background', useCoverArtBackground && !!lastCoverArtUrl);
    }

    function setCoverArtBackgroundEnabled(enabled) {
      const next = !!enabled;
      if (useCoverArtBackground === next) {
        applyCoverArtBackground();
        return;
      }
      useCoverArtBackground = next;
      applyCoverArtBackground();
    }

    function syncGeneralSettingsUI() {
      if (coverArtBackgroundToggle) {
        coverArtBackgroundToggle.checked = useCoverArtBackground;
      }
    }

    function applyMuteButtonState(btn, muted) {
      const active = !!muted;
      btn.dataset.muted = active ? 'true' : 'false';
      btn.innerHTML = active ? ICON_VOLUME_OFF : ICON_VOLUME_ON;
      btn.title = active ? 'Unmute' : 'Mute';
      btn.setAttribute('aria-label', active ? 'Unmute' : 'Mute');
      if (active) {
        btn.style.borderColor = '#f59e0b';
        btn.style.color = '#fbbf24';
        btn.style.background = 'rgba(251,191,36,0.18)';
      } else {
        btn.style.borderColor = 'rgba(255,255,255,0.14)';
        btn.style.color = '#e2e8f0';
        btn.style.background = 'rgba(15,23,42,0.8)';
      }
    }

    let nodesCache = [];
    let pendingNodesRender = null;
    let pendingNodesForce = false;
    const eqState = {};
    const eqDirtyNodes = {};
    const eqUpdateTimers = {};
    const camillaPendingNodes = {};
    const EQ_FREQUENCIES = {
      peq15: [25, 40, 63, 100, 160, 250, 400, 630, 1000, 1600, 2500, 4000, 6300, 10000, 16000],
      peq31: [20, 25, 31.5, 40, 50, 63, 80, 100, 125, 160, 200, 250, 315, 400, 500, 630, 800, 1000, 1250, 1600, 2000, 2500, 3150, 4000, 5000, 6300, 8000, 10000, 12500, 16000, 20000],
    };
    const EQ_GAIN_RANGE = { min: -12, max: 12 };
    const EQ_Q_RANGE = { min: 0.2, max: 10 };
    const EQ_PUSH_DEBOUNCE_MS = 120;
    const LOG_FREQ = { min: Math.log10(20), max: Math.log10(20000) };
    const EQ_SKIN_STORAGE_KEY = 'eq-skin';
    function loadEqSkinPreference() {
      try {
        const stored = localStorage.getItem(EQ_SKIN_STORAGE_KEY);
        if (stored === 'faders' || stored === 'classic') return stored;
      } catch (_) {
        /* ignore storage errors */
      }
      return 'classic';
    }
    function persistEqSkinPreference(value) {
      try {
        localStorage.setItem(EQ_SKIN_STORAGE_KEY, value);
      } catch (_) {
        /* ignore storage errors */
      }
    }
    let eqSkin = loadEqSkinPreference();
    const EQ_ICON_SVG = `
      <svg viewBox="0 0 24 24" aria-hidden="true" role="img" focusable="false" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round">
        <line x1="7" y1="3" x2="7" y2="9"></line>
        <line x1="7" y1="13" x2="7" y2="21"></line>
        <circle cx="7" cy="11" r="1.8" fill="currentColor" stroke="none"></circle>
        <line x1="12" y1="3" x2="12" y2="7"></line>
        <line x1="12" y1="13" x2="12" y2="21"></line>
        <circle cx="12" cy="9" r="1.8" fill="currentColor" stroke="none"></circle>
        <line x1="17" y1="3" x2="17" y2="11"></line>
        <line x1="17" y1="17" x2="17" y2="21"></line>
        <circle cx="17" cy="15" r="1.8" fill="currentColor" stroke="none"></circle>
      </svg>`;
    const ICON_VOLUME_ON = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><path d="M11 5L6 9H3v6h3l5 4z"/><path d="M15 9a3 3 0 010 6"/></svg>`;
    const ICON_VOLUME_OFF = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><path d="M11 5L6 9H3v6h3l5 4z"/><path d="M19 9l-6 6"/><path d="M13 9l6 6"/></svg>`;
    const ICON_SHUFFLE = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><path d="M16 3h4v4"/><path d="M4 20l16-16"/><path d="M4 4l5 5"/><path d="M15 15l5 5v-4"/></svg>`;
    const ICON_PREV = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><polygon points="15 18 9 12 15 6 15 18"/><line x1="6" y1="6" x2="6" y2="18"/></svg>`;
    const ICON_NEXT = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><polygon points="9 18 15 12 9 6 9 18"/><line x1="18" y1="6" x2="18" y2="18"/></svg>`;
    const ICON_PLAY = `<svg viewBox="0 0 24 24" fill="currentColor"><polygon points="8,5 20,12 8,19"/></svg>`;
    const ICON_PAUSE = `<svg viewBox="0 0 24 24" fill="currentColor"><rect x="7" y="5" width="4" height="14" rx="1"/><rect x="13" y="5" width="4" height="14" rx="1"/></svg>`;
    const ICON_REPEAT = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><polyline points="17 1 21 5 17 9"/><path d="M3 11V9a4 4 0 014-4h14"/><polyline points="7 23 3 19 7 15"/><path d="M21 13v2a4 4 0 01-4 4H3"/></svg>`;
    const COVER_ART_BACKDROP_OVERLAY = 'linear-gradient(135deg, rgba(2,6,23,0.92), rgba(2,6,23,0.65))';
    initializePlayerButtons();
    initCollapsiblePanels();
    let eqModal = null;
    const spotifyAuthBtn = document.getElementById('spotify-auth');
    const spotifyDashboardBtn = document.getElementById('spotify-dashboard');
    const spotifyLinkStatus = document.getElementById('spotify-link-status');

    function isInteractiveNodeElement(el) {
      if (!el) return false;
      const tag = el.tagName;
      if (tag === 'SELECT' || tag === 'TEXTAREA') return true;
      if (tag === 'INPUT') {
        const type = (el.type || '').toLowerCase();
        return type !== 'button' && type !== 'submit' && type !== 'reset';
      }
      return false;
    }

    function shouldDeferNodeRender() {
      const active = document.activeElement;
      if (!active) return false;
      if (!nodesEl.contains(active)) return false;
      return isInteractiveNodeElement(active);
    }

    function flushPendingNodesRender() {
      if (!pendingNodesRender) return;
      if (!pendingNodesForce && shouldDeferNodeRender()) return;
      const next = pendingNodesRender;
      pendingNodesRender = null;
      pendingNodesForce = false;
      commitRenderNodes(next);
    }

    nodesEl.addEventListener('focusout', () => {
      setTimeout(() => {
        if (!shouldDeferNodeRender()) {
          flushPendingNodesRender();
        }
      }, 0);
    }, true);

    document.addEventListener('visibilitychange', () => {
      if (!shouldDeferNodeRender()) {
        flushPendingNodesRender();
      }
    });

    function renderNodes(nodes, options = {}) {
      nodesCache = nodes;
      pendingNodesRender = nodes;
      if (options.force) {
        pendingNodesForce = true;
      }
      flushPendingNodesRender();
    }

    function commitRenderNodes(nodes) {
      nodesEl.innerHTML = '';
      if (!nodes.length) {
        nodesEl.innerHTML = '<div class="muted">No nodes registered yet.</div>';
        Object.keys(camillaPendingNodes).forEach(id => delete camillaPendingNodes[id]);
        refreshNodeSettingsModal();
        return;
      }
      nodes.forEach(n => {
        hydrateEqFromNode(n);
        const wrapper = document.createElement('div');
        wrapper.className = 'panel';
        const header = document.createElement('div');
        header.className = 'node-header';
        const title = document.createElement('div');
        title.style.display = 'flex';
        title.style.alignItems = 'center';
        title.style.gap = '8px';
        const titleStrong = document.createElement('strong');
        titleStrong.textContent = n.name;
        title.appendChild(titleStrong);
        header.appendChild(title);

        const gearWrap = document.createElement('div');
        gearWrap.className = 'node-gear';
        const gearBtn = document.createElement('button');
        gearBtn.className = 'node-icon-btn';
        gearBtn.textContent = '⚙︎';
        gearBtn.setAttribute('aria-label', `Settings for ${n.name}`);
        gearBtn.addEventListener('click', (event) => {
          event.stopPropagation();
          openNodeSettingsModal(n.id);
        });
        gearWrap.appendChild(gearBtn);
        header.appendChild(gearWrap);
        wrapper.appendChild(header);

        const statusRow = document.createElement('div');
        statusRow.className = 'node-status';
        const isBrowser = n.type === 'browser';
        const paired = !!n.paired;
        const configured = isBrowser ? true : !!n.configured;
        const online = isBrowser ? true : n.online !== false;
        const restarting = !!n.restarting;
        const updateAvailable = hasAgentUpdate(n);
        const updating = !!n.updating;
        const disableAgentControls = !isBrowser && (!paired || !configured || restarting || !online);
        const eqBtn = document.createElement('button');
        eqBtn.className = 'node-icon-btn';
        eqBtn.innerHTML = EQ_ICON_SVG;
        eqBtn.setAttribute('aria-label', 'Equalizer');
        eqBtn.title = 'Equalizer';
        eqBtn.disabled = n.type !== 'browser' && (!paired || !configured || restarting || !online);
        eqBtn.addEventListener('click', (event) => {
          event.stopPropagation();
          openEqModal(n.id, n.name);
        });
        gearWrap.insertBefore(eqBtn, gearBtn);
        if (!isBrowser) {
          const onlinePill = document.createElement('span');
          onlinePill.className = `status-pill ${online ? 'ok' : 'warn'}`;
          onlinePill.textContent = online ? 'Online' : 'Offline';
          title.appendChild(onlinePill);
        }
        if (isBrowser) {
          const browserPill = document.createElement('span');
          browserPill.className = 'status-pill ok';
          browserPill.textContent = 'Browser node';
          statusRow.appendChild(browserPill);
        } else if (!paired) {
          const pairPill = document.createElement('span');
          pairPill.className = 'status-pill warn';
          pairPill.textContent = 'Pairing required';
          statusRow.appendChild(pairPill);
        }
        if (!isBrowser) {
          if (!configured) {
            const cfgPill = document.createElement('span');
            cfgPill.className = 'status-pill warn';
            cfgPill.textContent = 'Needs config';
            statusRow.appendChild(cfgPill);
          }
        }
        if (!isBrowser && (updateAvailable || updating)) {
          const versionMeta = document.createElement('div');
          versionMeta.className = 'label';
          let text = n.agent_version ? `Agent ${n.agent_version}` : 'Agent version unknown';
          if (updating) {
            text += ' (updating…)';
          } else if (updateAvailable) {
            if (n.latest_agent_version) {
              text = n.agent_version
                ? `Agent ${n.agent_version} → ${n.latest_agent_version}`
                : `Update ${n.latest_agent_version} available`;
            } else {
              text += ' – update available';
            }
          }
          statusRow.appendChild(versionMeta);
          versionMeta.textContent = text;
        }
        if (restarting) {
          const restartPill = document.createElement('span');
          restartPill.className = 'status-pill warn';
          restartPill.textContent = 'Restarting';
          statusRow.appendChild(restartPill);
        }
        if (updating) {
          const updatingPill = document.createElement('span');
          updatingPill.className = 'status-pill warn';
          updatingPill.textContent = 'Updating';
          statusRow.appendChild(updatingPill);
        }
        wrapper.appendChild(statusRow);

        const volRow = document.createElement('div');
        volRow.style.display = 'grid';
        volRow.style.gridTemplateColumns = 'auto minmax(0, 1fr) auto';
        volRow.style.alignItems = 'center';
        volRow.style.gap = '8px';
        const muteBtn = document.createElement('button');
        muteBtn.className = 'node-mute-btn';
        muteBtn.disabled = disableAgentControls;
        muteBtn.addEventListener('click', () => toggleMute(n.id, muteBtn));
        applyMuteButtonState(muteBtn, n.muted === true);
        volRow.appendChild(muteBtn);
        const volInput = document.createElement('input');
        volInput.type = 'range';
        volInput.min = 0;
        volInput.max = 100;
        const parsedVolume = Number(n.volume_percent);
        volInput.value = Number.isFinite(parsedVolume) ? parsedVolume : 75;
        volInput.disabled = disableAgentControls;
        volInput.style.width = '100%';
        setRangeProgress(volInput, volInput.value, volInput.max || 100);
        volInput.addEventListener('input', () => setRangeProgress(volInput, volInput.value, volInput.max || 100));
        volInput.addEventListener('change', () => setNodeVolume(n.id, volInput.value));
        volRow.appendChild(volInput);
        wrapper.appendChild(volRow);

        if (n.type === 'browser') {
          const panLabel = document.createElement('div');
          panLabel.className = 'label';
          let currentPan = typeof n.pan === 'number' ? n.pan : 0;
          panLabel.innerText = `Pan – ${describePan(currentPan)}`;
          wrapper.appendChild(panLabel);

          const panInput = document.createElement('input');
          panInput.type = 'range';
          panInput.min = -100;
          panInput.max = 100;
          panInput.step = 2;
          panInput.value = Math.round(currentPan * 100);
          setRangeProgress(panInput, panInput.value, panInput.max || 100);
          panInput.addEventListener('input', () => {
            const nextPan = Number(panInput.value) / 100;
            panLabel.innerText = `Pan – ${describePan(nextPan)}`;
            setRangeProgress(panInput, panInput.value, panInput.max || 100);
          });
          panInput.addEventListener('change', async () => {
            const nextPan = Math.max(-1, Math.min(1, Number(panInput.value) / 100));
            try {
              await setNodePan(n.id, nextPan);
              currentPan = nextPan;
            } catch (err) {
              panInput.value = Math.round(currentPan * 100);
              panLabel.innerText = `Pan – ${describePan(currentPan)}`;
            }
            setRangeProgress(panInput, panInput.value, panInput.max || 100);
          });
          wrapper.appendChild(panInput);
        }

        const actions = document.createElement('div');
        actions.className = 'node-actions';
        if (n.type !== 'browser' && updateAvailable) {
          const updateBtn = document.createElement('button');
          updateBtn.className = 'small-btn';
          updateBtn.textContent = updating ? 'Updating…' : 'Update node';
          updateBtn.disabled = !paired || restarting || updating;
          if (!updating) {
            updateBtn.addEventListener('click', () => updateNode(n.id, updateBtn));
          }
          actions.appendChild(updateBtn);
        }
        wrapper.appendChild(actions);

        nodesEl.appendChild(wrapper);
      });

      const nodeIds = new Set(nodes.map(n => n.id));
      Object.keys(camillaPendingNodes).forEach(id => {
        if (!nodeIds.has(id)) delete camillaPendingNodes[id];
      });
      refreshNodeSettingsModal();
    }

    function renderClients(groups, target) {
      target.innerHTML = '';
      groups.forEach(group => {
        group.clients.forEach(c => {
          const panel = document.createElement('div');
          panel.style.marginBottom = '10px';
          const row = document.createElement('div');
          row.style.display = 'grid';
          row.style.gridTemplateColumns = '1fr 120px';
          row.style.gap = '12px';
          row.style.alignItems = 'center';
          const label = document.createElement('div');
          label.innerHTML = `<div>${c.friendlyName || c.id}</div><div class="label">${group.stream?.name || 'Spotify'}</div>`;
          const input = document.createElement('input');
          input.type = 'range';
          input.min = 0;
          input.max = 100;
          input.value = c.config?.volume?.percent ?? 50;
          setRangeProgress(input, input.value, input.max || 100);
          input.addEventListener('input', () => setRangeProgress(input, input.value, input.max || 100));
          input.addEventListener('change', () => setVolume(c.id, input.value));
          row.appendChild(label);
          row.appendChild(input);
          panel.appendChild(row);
          target.appendChild(panel);
        });
      });
      if (!groups.length) {
        target.innerHTML = '<div class="muted">No clients connected yet.</div>';
      }
    }

    function appendDiscovered(items) {
      const list = Array.isArray(items) ? items : [items];
      list.forEach(item => {
        if (!item || !item.url) return;
        const row = document.createElement('div');
        row.className = 'panel discover-row';
        row.style.marginBottom = '8px';
        const title = document.createElement('div');
        const versionLabel = item.version ? `Agent ${item.version}` : 'Version unknown';
        title.innerHTML = `<strong>${item.host}</strong> <span class="muted">${item.url}</span><div class="label">${versionLabel}</div>`;
        const nameInput = document.createElement('input');
        const existing = findNodeByFingerprint(item.fingerprint);
        if (existing) {
          nameInput.value = existing.name || existing.id || `Node ${item.host}`;
          nameInput.disabled = true;
        } else {
          nameInput.value = `Node ${item.host}`;
        }
        nameInput.style.marginTop = '6px';
        const btn = document.createElement('button');
        btn.className = 'small-btn';
        btn.textContent = existing ? 'Relink node' : 'Register';
        btn.style.marginTop = '6px';
        btn.addEventListener('click', () => registerNodeWithName(
          existing ? existing.name : nameInput.value,
          item.url,
          btn,
          existing ? existing.id : undefined,
          item.fingerprint,
        ));
        row.appendChild(title);
        row.appendChild(nameInput);
        if (existing) {
          const hint = document.createElement('div');
          hint.className = 'label';
          hint.textContent = `Matches registered node “${existing.name || existing.id}”`;
          row.appendChild(hint);
        }
        row.appendChild(btn);
        discoverList.appendChild(row);
      });
    }

    async function fetchStatus() {
      try {
        clearMessages();
        const res = await fetch('/api/snapcast/status');
        await ensureOk(res);
        const data = await res.json();
        renderClients(data.server?.groups || [], clientsSettingsEl);
      } catch (err) {
        showError(`Failed to fetch snapcast status: ${err.message}`);
      }
    }

    async function fetchNodes(options = {}) {
      try {
        const res = await fetch('/api/nodes');
        await ensureOk(res);
        const data = await res.json();
        renderNodes(data.nodes || [], options);
      } catch (err) {
        showError(`Failed to load nodes: ${err.message}`);
      }
    }

    async function fetchSpotifyConfig() {
      try {
        const res = await fetch('/api/config/spotify');
        await ensureOk(res);
        const cfg = await res.json();
        spName.value = cfg.device_name || 'RoomCast';
        spBitrate.value = cfg.bitrate || 320;
        spInitVol.value = cfg.initial_volume ?? 75;
        setRangeProgress(spInitVol, spInitVol.value, spInitVol.max || 100);
        spNormalise.checked = cfg.normalisation ?? true;
        spClientId.value = cfg.client_id || '';
        spRedirect.value = cfg.redirect_uri || '';
        if (cfg.has_client_secret) spClientSecret.placeholder = 'stored';
        else spClientSecret.placeholder = 'client secret';
        if (spotifyLinkStatus) {
          if (cfg.has_oauth_token) {
            spotifyLinkStatus.textContent = 'Spotify account linked via OAuth';
            spotifyLinkStatus.className = 'status-pill ok';
          } else {
            spotifyLinkStatus.textContent = 'Spotify account not linked';
            spotifyLinkStatus.className = 'status-pill warn';
          }
        }
      } catch (err) {
        showError(`Failed to load Spotify config: ${err.message}`);
      }
    }

    async function fetchLibrespotStatus() {
      try {
        const res = await fetch('/api/librespot/status');
        await ensureOk(res);
        const data = await res.json();
        librespotStatus.innerText = `Status: ${data.state || 'unknown'}${data.message ? ' – ' + data.message : ''}`;
      } catch (err) {
        librespotStatus.innerText = `Failed to load status: ${err.message}`;
      }
    }

    async function discoverNodes() {
      if (discoverAbortController) {
        discoverAbortController.abort();
        discoverAbortController = null;
      }
      discoverResultsCount = 0;
      discoverList.innerHTML = '';
      discoverStatus.textContent = 'Preparing scan…';
      discoverSpinner.style.display = 'block';
      startDiscoverBtn.disabled = true;
      startDiscoverBtn.textContent = 'Scanning…';
      discoverAbortController = new AbortController();
      const decoder = new TextDecoder();
      let buffer = '';

      const processLine = (line) => {
        if (!line) return;
        let payload;
        try {
          payload = JSON.parse(line);
        } catch (err) {
          return;
        }
        if (payload.type === 'start') {
          const nets = Array.isArray(payload.networks) && payload.networks.length ? payload.networks.join(', ') : 'detected networks';
          const limited = payload.limited ? ' (limited – narrow networks for deeper scan)' : '';
          discoverStatus.textContent = `Scanning ${nets} (${payload.host_count ?? '?'} hosts)${limited}.`;
          return;
        }
        if (payload.type === 'discovered') {
          if (discoverResultsCount === 0) {
            discoverList.innerHTML = '';
          }
          discoverResultsCount += 1;
          appendDiscovered(payload.data);
          discoverStatus.textContent = `Found ${discoverResultsCount} node${discoverResultsCount === 1 ? '' : 's'} so far…`;
          return;
        }
        if (payload.type === 'complete') {
          discoverStatus.textContent = payload.found ? `Scan complete – ${payload.found} node${payload.found === 1 ? '' : 's'} found.` : 'Scan complete – no nodes responded.';
          return;
        }
        if (payload.type === 'cancelled') {
          discoverStatus.textContent = `Scan cancelled after ${payload.found || discoverResultsCount} result${(payload.found || discoverResultsCount) === 1 ? '' : 's'}.`;
          return;
        }
        if (payload.type === 'error') {
          discoverStatus.textContent = `Discovery error: ${payload.message || 'unknown error'}`;
        }
      };

      try {
        const res = await fetch('/api/nodes/discover', { signal: discoverAbortController.signal });
        await ensureOk(res);
        if (!res.body) throw new Error('Streaming not supported in this browser');
        const reader = res.body.getReader();
        while (true) {
          const { value, done } = await reader.read();
          if (done) break;
          buffer += decoder.decode(value, { stream: true });
          let idx = buffer.indexOf('\n');
          while (idx >= 0) {
            const line = buffer.slice(0, idx).trim();
            buffer = buffer.slice(idx + 1);
            processLine(line);
            idx = buffer.indexOf('\n');
          }
        }
        const tail = buffer.trim();
        if (tail) processLine(tail);
      } catch (err) {
        if (err.name === 'AbortError') {
          discoverStatus.textContent = 'Scan cancelled.';
        } else {
          discoverStatus.textContent = `Failed to discover: ${err.message}`;
        }
      } finally {
        discoverSpinner.style.display = 'none';
        startDiscoverBtn.disabled = false;
        startDiscoverBtn.textContent = 'Scan';
        discoverAbortController = null;
        if (!discoverResultsCount && discoverList.children.length === 0) {
          discoverList.innerHTML = '<div class="muted">No agents found yet. Ensure nodes run on the same subnet and respond on port 9700.</div>';
        }
      }
    }

    async function setVolume(clientId, percent) {
      try {
        const res = await fetch(`/api/snapcast/clients/${clientId}/volume`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ percent: Number(percent) }),
        });
        await ensureOk(res);
      } catch (err) {
        showError(`Failed to set volume: ${err.message}`);
      }
    }

    async function setNodeVolume(nodeId, percent) {
      try {
        const res = await fetch(`/api/nodes/${nodeId}/volume`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ percent: Number(percent) }),
        });
        await ensureOk(res);
        showSuccess('Node volume updated');
      } catch (err) {
        showError(`Failed to set node volume: ${err.message}`);
      }
    }

    async function setNodePan(nodeId, pan) {
      const clamped = Math.max(-1, Math.min(1, Number(pan)));
      try {
        const res = await fetch(`/api/nodes/${nodeId}/pan`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ pan: clamped }),
        });
        await ensureOk(res);
        showSuccess('Web node pan updated');
      } catch (err) {
        showError(`Failed to set pan: ${err.message}`);
        throw err;
      }
    }

    async function toggleMute(nodeId, btn) {
      const currentlyMuted = btn.dataset.muted === 'true';
      btn.disabled = true;
      try {
        const res = await fetch(`/api/nodes/${nodeId}/mute`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ muted: !currentlyMuted }),
        });
        await ensureOk(res);
        const data = await res.json();
        const muted = data?.result?.muted ?? !currentlyMuted;
        applyMuteButtonState(btn, muted);
      } catch (err) {
        showError(`Failed to toggle mute: ${err.message}`);
      } finally {
        btn.disabled = false;
      }
    }

    async function pairNode(nodeId, btn) {
      if (btn) btn.disabled = true;
      try {
        const res = await fetch(`/api/nodes/${nodeId}/pair`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ force: true }),
        });
        await ensureOk(res);
        showSuccess('Node paired');
        await fetchNodes();
      } catch (err) {
        showError(`Failed to pair node: ${err.message}`);
      } finally {
        if (btn) btn.disabled = false;
      }
    }

    async function renameNode(nodeId, currentName) {
      const nextName = prompt('Rename node', currentName || 'Node');
      if (nextName === null) return;
      const trimmed = nextName.trim();
      if (!trimmed) {
        showError('Node name cannot be empty');
        return;
      }
      try {
        const res = await fetch(`/api/nodes/${nodeId}/rename`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name: trimmed }),
        });
        await ensureOk(res);
        showSuccess('Node renamed');
        await fetchNodes();
      } catch (err) {
        showError(`Failed to rename node: ${err.message}`);
      }
    }

    async function configureNode(nodeId, btn) {
      if (btn) btn.disabled = true;
      try {
        const res = await fetch(`/api/nodes/${nodeId}/configure`, { method: 'POST' });
        await ensureOk(res);
        showSuccess('Node audio configured');
        await fetchNodes();
      } catch (err) {
        showError(`Failed to configure node: ${err.message}`);
      } finally {
        if (btn) btn.disabled = false;
      }
    }

    async function setNodeOutput(nodeId, deviceId, selectEl) {
      if (!deviceId) return;
      const originalValue = selectEl ? selectEl.value : null;
      if (selectEl) selectEl.disabled = true;
      try {
        const res = await fetch(`/api/nodes/${nodeId}/outputs`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ device: deviceId }),
        });
        await ensureOk(res);
        showSuccess('Audio output updated');
        await fetchNodes({ force: true });
      } catch (err) {
        showError(`Failed to set output: ${err.message}`);
        if (selectEl && originalValue !== null) {
          selectEl.value = originalValue;
        }
      } finally {
        if (selectEl) selectEl.disabled = false;
      }
    }

    async function checkNodeUpdates(nodeId, btn) {
      const originalLabel = btn ? btn.textContent : '';
      if (btn) {
        btn.disabled = true;
        btn.textContent = 'Checking…';
      }
      try {
        const res = await fetch(`/api/nodes/${nodeId}/check-updates`, { method: 'POST' });
        await ensureOk(res);
        const data = await res.json().catch(() => ({}));
        if (data?.update_available) {
          showSuccess('Update available for this node.');
        } else {
          showSuccess('Node is up to date.');
        }
        await fetchNodes();
      } catch (err) {
        showError(`Failed to check updates: ${err.message}`);
      } finally {
        if (btn) {
          btn.disabled = false;
          btn.textContent = originalLabel || 'Check for updates';
        }
      }
    }

    async function updateNode(nodeId, btn) {
      const originalLabel = btn ? btn.textContent : '';
      let failed = false;
      if (btn) {
        btn.disabled = true;
        btn.textContent = 'Updating…';
      }
      try {
        const res = await fetch(`/api/nodes/${nodeId}/update`, { method: 'POST' });
        await ensureOk(res);
        showSuccess('Node update triggered. Agent will restart shortly.');
        fetchNodes();
        setTimeout(fetchNodes, 15000);
      } catch (err) {
        showError(`Failed to update node: ${err.message}`);
        failed = true;
      } finally {
        if (btn && failed) {
          btn.disabled = false;
          btn.textContent = originalLabel || 'Update node';
        }
      }
    }

    async function restartNode(nodeId, btn) {
      if (btn) {
        btn.disabled = true;
        btn.textContent = 'Restarting…';
      }
      try {
        const res = await fetch(`/api/nodes/${nodeId}/restart`, { method: 'POST' });
        await ensureOk(res);
        showSuccess('Node restart requested');
        await fetchNodes();
      } catch (err) {
        showError(`Failed to restart node: ${err.message}`);
        if (btn) {
          btn.disabled = false;
          btn.textContent = 'Restart node';
        }
      }
    }

    async function unregisterNode(nodeId) {
      try {
        const res = await fetch(`/api/nodes/${nodeId}`, { method: 'DELETE' });
        await ensureOk(res);
        showSuccess('Node unregistered');
        await fetchNodes();
      } catch (err) {
        showError(`Failed to unregister node: ${err.message}`);
      }
    }

    function closeNodeSettingsModal() {
      if (nodeSettingsModal) {
        nodeSettingsModal.remove();
        nodeSettingsModal = null;
        nodeSettingsContent = null;
        nodeSettingsTitle = null;
      }
      nodeSettingsNodeId = null;
    }

    function openNodeSettingsModal(nodeId) {
      nodeSettingsNodeId = nodeId;
      if (!nodeSettingsModal) {
        nodeSettingsModal = document.createElement('div');
        nodeSettingsModal.className = 'settings-overlay';
        const card = document.createElement('div');
        card.className = 'settings-card';
        const header = document.createElement('div');
        header.className = 'settings-header';
        nodeSettingsTitle = document.createElement('div');
        nodeSettingsTitle.className = 'section-title';
        nodeSettingsTitle.style.margin = '0';
        header.appendChild(nodeSettingsTitle);
        const closeBtn = document.createElement('button');
        closeBtn.className = 'icon-btn';
        closeBtn.textContent = '✕';
        closeBtn.addEventListener('click', closeNodeSettingsModal);
        header.appendChild(closeBtn);
        card.appendChild(header);
        nodeSettingsContent = document.createElement('div');
        nodeSettingsContent.className = 'node-settings-content';
        card.appendChild(nodeSettingsContent);
        nodeSettingsModal.appendChild(card);
        nodeSettingsModal.addEventListener('click', (evt) => {
          if (evt.target === nodeSettingsModal) closeNodeSettingsModal();
        });
        document.body.appendChild(nodeSettingsModal);
      }
      nodeSettingsModal.style.display = 'flex';
      renderNodeSettingsContent();
    }

    function refreshNodeSettingsModal() {
      if (nodeSettingsModal && nodeSettingsNodeId) {
        renderNodeSettingsContent();
      }
    }

    function renderNodeSettingsContent() {
      if (!nodeSettingsModal || !nodeSettingsContent || !nodeSettingsNodeId) return;
      const node = nodesCache.find(n => n.id === nodeSettingsNodeId);
      if (!node) {
        closeNodeSettingsModal();
        return;
      }
      nodeSettingsTitle.textContent = `Node settings – ${node.name || 'Node'}`;
      nodeSettingsContent.innerHTML = '';

      const isBrowser = node.type === 'browser';
      const paired = !!node.paired;
      const configured = isBrowser ? true : !!node.configured;
      const online = isBrowser ? true : node.online !== false;
      const restarting = !!node.restarting;
      const updating = !!node.updating;
      const updateAvailable = hasAgentUpdate(node);
      const outputs = node.outputs || {};
      const outputOptions = Array.isArray(outputs.options) ? outputs.options : [];
      const selectedOutput = outputs.selected || node.playback_device || '';
      const disableOutputs = !isBrowser && (!paired || !configured || restarting || !online || updating);

      const detailsPanel = document.createElement('div');
      detailsPanel.className = 'panel';
      const detailsTitle = document.createElement('div');
      detailsTitle.className = 'section-title';
      detailsTitle.textContent = 'Details';
      detailsPanel.appendChild(detailsTitle);
      detailsPanel.appendChild(createMetaRow('Node type', isBrowser ? 'Browser node' : 'Hardware node'));
      if (node.url) {
        detailsPanel.appendChild(createMetaRow('Endpoint', node.url));
      }
      const host = describeNodeHost(node.url);
      if (host && host !== node.url) {
        detailsPanel.appendChild(createMetaRow('Host/IP', host));
      }
      if (node.agent_version) {
        let versionText = `Agent ${node.agent_version}`;
        if (updating) versionText += ' (updating…)';
        else if (updateAvailable && node.latest_agent_version) versionText += ` → ${node.latest_agent_version}`;
        detailsPanel.appendChild(createMetaRow('Version', versionText));
      }
      if (node.fingerprint) {
        detailsPanel.appendChild(createMetaRow('Fingerprint', node.fingerprint));
      }
      nodeSettingsContent.appendChild(detailsPanel);

      if (!isBrowser) {
        const audioPanel = document.createElement('div');
        audioPanel.className = 'panel';
        const audioTitle = document.createElement('div');
        audioTitle.className = 'section-title';
        audioTitle.textContent = 'Audio output';
        audioPanel.appendChild(audioTitle);
        if (!outputOptions.length) {
          const empty = document.createElement('div');
          empty.className = 'muted';
          empty.textContent = 'No outputs detected yet.';
          audioPanel.appendChild(empty);
          if (selectedOutput) {
            audioPanel.appendChild(createMetaRow('Current device', selectedOutput));
          }
        } else {
          const select = document.createElement('select');
          select.style.width = '100%';
          const mappedOptions = [...outputOptions];
          if (selectedOutput && !mappedOptions.some(opt => opt.id === selectedOutput)) {
            mappedOptions.unshift({ id: selectedOutput, label: `${selectedOutput} (current)` });
          }
          mappedOptions.forEach(opt => {
            const optionEl = document.createElement('option');
            optionEl.value = opt.id;
            optionEl.textContent = opt.label || opt.id;
            select.appendChild(optionEl);
          });
          if (selectedOutput) {
            select.value = selectedOutput;
          }
          select.disabled = disableOutputs;
          select.addEventListener('change', () => {
            if (!select.value) return;
            setNodeOutput(node.id, select.value, select);
          });
          audioPanel.appendChild(select);
        }
        nodeSettingsContent.appendChild(audioPanel);
      }

      const actionsPanel = document.createElement('div');
      actionsPanel.className = 'panel';
      const actionsTitle = document.createElement('div');
      actionsTitle.className = 'section-title';
      actionsTitle.textContent = 'Actions';
      actionsPanel.appendChild(actionsTitle);
      const actionStack = document.createElement('div');
      actionStack.className = 'modal-actions';

      actionStack.appendChild(createNodeSettingsAction('Rename node', () => renameNode(node.id, node.name)));
      if (!isBrowser) {
        const pairBtn = createNodeSettingsAction(paired ? 'Rotate key' : 'Pair node', (btn) => pairNode(node.id, btn), { disabled: restarting });
        if (!paired) {
          pairBtn.style.background = 'linear-gradient(135deg, #f97316, #ea580c)';
        }
        actionStack.appendChild(pairBtn);

        const configBtn = createNodeSettingsAction(configured ? 'Reconfigure audio' : 'Configure audio', (btn) => configureNode(node.id, btn), { disabled: !paired || restarting });
        if (!configured) {
          configBtn.style.background = 'linear-gradient(135deg, #22c55e, #16a34a)';
        }
        actionStack.appendChild(configBtn);

        const restartBtn = createNodeSettingsAction(restarting ? 'Restarting…' : 'Restart node', (btn) => restartNode(node.id, btn), { disabled: restarting });
        actionStack.appendChild(restartBtn);

        const checkBtn = createNodeSettingsAction('Check for updates', (btn) => checkNodeUpdates(node.id, btn), { disabled: restarting || updating });
        actionStack.appendChild(checkBtn);

        if (updateAvailable) {
          const updateBtn = createNodeSettingsAction(updating ? 'Updating…' : 'Update node', (btn) => updateNode(node.id, btn), { disabled: restarting || updating });
          actionStack.appendChild(updateBtn);
        }
      }
      const unregisterBtn = createNodeSettingsAction('Unregister node', () => {
        closeNodeSettingsModal();
        unregisterNode(node.id);
      }, { danger: true });
      actionStack.appendChild(unregisterBtn);
      actionsPanel.appendChild(actionStack);
      nodeSettingsContent.appendChild(actionsPanel);
    }

    function createNodeSettingsAction(label, handler, options = {}) {
      const btn = document.createElement('button');
      btn.textContent = label;
      if (options.danger) {
        btn.style.background = 'linear-gradient(135deg, #ef4444, #dc2626)';
        btn.style.color = '#fff';
      } else if (options.secondary) {
        btn.style.background = 'rgba(255,255,255,0.08)';
        btn.style.color = '#e2e8f0';
      }
      btn.disabled = !!options.disabled;
      if (typeof handler === 'function') {
        btn.addEventListener('click', () => handler(btn));
      }
      return btn;
    }

    function createMetaRow(labelText, valueText) {
      const row = document.createElement('div');
      row.className = 'node-meta-row';
      const label = document.createElement('div');
      label.className = 'label';
      label.textContent = labelText;
      label.style.marginTop = '0';
      const value = document.createElement('div');
      value.className = 'node-meta-value';
      value.textContent = valueText || '—';
      row.appendChild(label);
      row.appendChild(value);
      return row;
    }

    function clampValue(val, min, max) {
      return Math.min(max, Math.max(min, val));
    }

    function isEqDirty(nodeId) {
      return !!eqDirtyNodes[nodeId];
    }

    function markEqDirty(nodeId) {
      eqDirtyNodes[nodeId] = true;
    }

    function markEqClean(nodeId) {
      eqDirtyNodes[nodeId] = false;
    }

    function eqBandsMatch(a = [], b = []) {
      if (!Array.isArray(a) || !Array.isArray(b)) return false;
      if (a.length !== b.length) return false;
      for (let i = 0; i < a.length; i += 1) {
        const bandA = a[i] || {};
        const bandB = b[i] || {};
        if (Math.abs(Number(bandA.freq || 0) - Number(bandB.freq || 0)) > 0.01) return false;
        if (Math.abs(Number(bandA.gain || 0) - Number(bandB.gain || 0)) > 0.01) return false;
        if (Math.abs(Number(bandA.q || 0) - Number(bandB.q || 0)) > 0.01) return false;
      }
      return true;
    }

    function eqStatesMatch(a, b) {
      if (!a || !b) return false;
      if (a.mode !== b.mode) return false;
      return eqBandsMatch(a.bands, b.bands);
    }

    function defaultEqBands(mode) {
      const freqs = EQ_FREQUENCIES[mode] || EQ_FREQUENCIES.peq15;
      return freqs.map(freq => ({ freq, gain: 0, q: 1 }));
    }

    function getEqSkin() {
      return eqSkin === 'faders' ? 'faders' : 'classic';
    }

    function setEqSkin(nextSkin) {
      const normalized = nextSkin === 'faders' ? 'faders' : 'classic';
      if (eqSkin === normalized) return;
      eqSkin = normalized;
      persistEqSkinPreference(eqSkin);
    }

    function normalizeEqPayload(payload) {
      if (!payload) return { mode: 'peq15', bands: defaultEqBands('peq15') };
      const sourceBands = Array.isArray(payload.bands) ? payload.bands : [];
      const mode = (payload.preset === 'peq31' || Number(payload.band_count) >= 31) ? 'peq31' : 'peq15';
      const template = defaultEqBands(mode);
      template.forEach((band, idx) => {
        const src = sourceBands[idx];
        if (!src) return;
        band.freq = clampValue(Number(src.freq) || band.freq, 20, 20000);
        band.gain = clampValue(Number(src.gain) || 0, EQ_GAIN_RANGE.min, EQ_GAIN_RANGE.max);
        band.q = clampValue(Number(src.q) || 1, EQ_Q_RANGE.min, EQ_Q_RANGE.max);
      });
      return { mode, bands: template };
    }

    function hydrateEqFromNode(node) {
      if (!node || !node.id) return;
      const normalized = normalizeEqPayload(node.eq);
      const current = eqState[node.id];
      if (!current) {
        eqState[node.id] = normalized;
        markEqClean(node.id);
        return;
      }
      if (isEqDirty(node.id)) return;
      if (!eqStatesMatch(current, normalized)) {
        eqState[node.id] = normalized;
      }
      markEqClean(node.id);
    }

    function getEqState(nodeId) {
      if (!eqState[nodeId]) {
        eqState[nodeId] = { mode: 'peq15', bands: defaultEqBands('peq15') };
      }
      return eqState[nodeId];
    }

    function setEqMode(nodeId, mode) {
      const target = EQ_FREQUENCIES[mode] ? mode : 'peq15';
      const nextBands = defaultEqBands(target);
      const current = getEqState(nodeId).bands;
      nextBands.forEach((band, idx) => {
        if (current[idx]) {
          band.freq = clampValue(current[idx].freq, 20, 20000);
          band.gain = clampValue(current[idx].gain, EQ_GAIN_RANGE.min, EQ_GAIN_RANGE.max);
          band.q = clampValue(current[idx].q, EQ_Q_RANGE.min, EQ_Q_RANGE.max);
        }
      });
      eqState[nodeId] = { mode: target, bands: nextBands };
      markEqDirty(nodeId);
    }

    function freqToSlider(freq) {
      const logF = Math.log10(clampValue(freq, 20, 20000));
      const ratio = (logF - LOG_FREQ.min) / (LOG_FREQ.max - LOG_FREQ.min);
      return Math.round(ratio * 1000);
    }

    function sliderToFreq(value) {
      const ratio = clampValue(value, 0, 1000) / 1000;
      const logF = LOG_FREQ.min + ratio * (LOG_FREQ.max - LOG_FREQ.min);
      return Math.pow(10, logF);
    }

    function scheduleEqPush(nodeId) {
      clearTimeout(eqUpdateTimers[nodeId]);
      eqUpdateTimers[nodeId] = setTimeout(() => pushEq(nodeId), EQ_PUSH_DEBOUNCE_MS);
    }

    function handleCamillaPending(nodeId, pending) {
      const prev = camillaPendingNodes[nodeId] || false;
      camillaPendingNodes[nodeId] = pending;
      if (prev === pending) return;
      const node = nodesCache.find(n => n.id === nodeId);
      const label = node?.name || 'Node';
      if (pending) {
        showError(`${label}: EQ queued until DSP is available`);
      } else {
        showSuccess(`${label}: EQ applied after DSP recovery`);
      }
    }

    async function pushEq(nodeId) {
      const state = getEqState(nodeId);
      const payload = {
        preset: state.mode,
        band_count: state.bands.length,
        bands: state.bands.map(b => ({
          freq: Number(b.freq),
          gain: Number(b.gain),
          q: Number(b.q),
        })),
      };
      try {
        const res = await fetch(`/api/nodes/${nodeId}/eq`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
        });
        await ensureOk(res);
        let data = null;
        try {
          data = await res.json();
        } catch (_) {
          data = null;
        }
        const node = nodesCache.find(n => n.id === nodeId);
        if (node) {
          node.eq = {
            preset: payload.preset,
            band_count: payload.band_count,
            bands: payload.bands.map(b => ({ ...b })),
          };
        }
        markEqClean(nodeId);
        const pending = !!data?.result?.camilla_pending;
        handleCamillaPending(nodeId, pending);
      } catch (err) {
        showError(`Failed to update EQ: ${err.message}`);
      }
    }

    function renderEqBandsClassic(nodeId, container) {
      const state = getEqState(nodeId);
      container.innerHTML = '';
      state.bands.forEach((band, idx) => {
        const row = document.createElement('div');
        row.className = 'eq-band-row';

        const label = document.createElement('div');
        label.className = 'eq-band-label';
        label.textContent = `#${idx + 1}`;
        row.appendChild(label);

        const freqCell = document.createElement('div');
        freqCell.className = 'eq-band-cell';
        const freqLabel = document.createElement('label');
        freqLabel.textContent = 'Freq (Hz)';
        const freqInput = document.createElement('input');
        freqInput.type = 'number';
        freqInput.min = 20;
        freqInput.max = 20000;
        freqInput.value = Math.round(band.freq);
        freqInput.addEventListener('change', () => {
          band.freq = clampValue(Number(freqInput.value) || band.freq, 20, 20000);
          freqSlider.value = freqToSlider(band.freq);
          setRangeProgress(freqSlider, freqSlider.value, freqSlider.max || 1000);
          markEqDirty(nodeId);
          scheduleEqPush(nodeId);
        });
        const freqSlider = document.createElement('input');
        freqSlider.type = 'range';
        freqSlider.min = 0;
        freqSlider.max = 1000;
        freqSlider.value = freqToSlider(band.freq);
        setRangeProgress(freqSlider, freqSlider.value, freqSlider.max || 1000);
        freqSlider.addEventListener('input', () => {
          band.freq = clampValue(sliderToFreq(Number(freqSlider.value)), 20, 20000);
          freqInput.value = Math.round(band.freq);
          setRangeProgress(freqSlider, freqSlider.value, freqSlider.max || 1000);
          markEqDirty(nodeId);
          scheduleEqPush(nodeId);
        });
        freqCell.appendChild(freqLabel);
        freqCell.appendChild(freqInput);
        freqCell.appendChild(freqSlider);
        row.appendChild(freqCell);

        const gainCell = document.createElement('div');
        gainCell.className = 'eq-band-cell';
        const gainLabel = document.createElement('label');
        gainLabel.textContent = 'Gain (dB)';
        const gainSlider = document.createElement('input');
        gainSlider.type = 'range';
        gainSlider.min = EQ_GAIN_RANGE.min;
        gainSlider.max = EQ_GAIN_RANGE.max;
        gainSlider.step = 0.5;
        gainSlider.value = band.gain;
        setRangeProgress(gainSlider, gainSlider.value, gainSlider.max || 1);
        const gainValue = document.createElement('div');
        gainValue.className = 'muted';
        gainValue.textContent = `${band.gain.toFixed(1)} dB`;
        gainSlider.addEventListener('input', () => {
          band.gain = clampValue(Number(gainSlider.value), EQ_GAIN_RANGE.min, EQ_GAIN_RANGE.max);
          gainValue.textContent = `${band.gain.toFixed(1)} dB`;
          setRangeProgress(gainSlider, gainSlider.value, gainSlider.max || 1);
          markEqDirty(nodeId);
          scheduleEqPush(nodeId);
        });
        gainCell.appendChild(gainLabel);
        gainCell.appendChild(gainSlider);
        gainCell.appendChild(gainValue);
        row.appendChild(gainCell);

        const qCell = document.createElement('div');
        qCell.className = 'eq-band-cell';
        const qLabel = document.createElement('label');
        qLabel.textContent = 'Q';
        const qInput = document.createElement('input');
        qInput.type = 'number';
        qInput.step = 0.1;
        qInput.min = EQ_Q_RANGE.min;
        qInput.max = EQ_Q_RANGE.max;
        qInput.value = band.q.toFixed(2);
        qInput.addEventListener('change', () => {
          band.q = clampValue(Number(qInput.value) || band.q, EQ_Q_RANGE.min, EQ_Q_RANGE.max);
          markEqDirty(nodeId);
          scheduleEqPush(nodeId);
        });
        qCell.appendChild(qLabel);
        qCell.appendChild(qInput);
        row.appendChild(qCell);

        container.appendChild(row);
      });
    }

    function renderEqBandsFaders(nodeId, container) {
      const state = getEqState(nodeId);
      container.innerHTML = '';
      const view = document.createElement('div');
      view.className = 'eq-fader-view';
      state.bands.forEach((band, idx) => {
        const fader = document.createElement('div');
        fader.className = 'eq-fader';

        const meta = document.createElement('div');
        meta.className = 'eq-fader-meta';
        const bandIndex = document.createElement('span');
        bandIndex.textContent = `#${idx + 1}`;
        const freqLabel = document.createElement('span');
        freqLabel.textContent = `${Math.round(band.freq)} Hz`;
        meta.appendChild(bandIndex);
        meta.appendChild(freqLabel);
        fader.appendChild(meta);

        const sliderWrap = document.createElement('div');
        sliderWrap.className = 'eq-fader-slider-wrap';
        const track = document.createElement('div');
        track.className = 'eq-fader-track';
        sliderWrap.appendChild(track);
        const gainSlider = document.createElement('input');
        gainSlider.type = 'range';
        gainSlider.className = 'eq-fader-slider';
        gainSlider.setAttribute('orient', 'vertical');
        gainSlider.setAttribute('aria-label', `Gain ${Math.round(band.freq)} Hz`);
        gainSlider.min = EQ_GAIN_RANGE.min;
        gainSlider.max = EQ_GAIN_RANGE.max;
        gainSlider.step = 0.5;
        gainSlider.value = band.gain.toFixed(1);
        const gainValue = document.createElement('div');
        gainValue.className = 'eq-fader-gain';
        gainValue.textContent = `${band.gain.toFixed(1)} dB`;
        const knob = document.createElement('div');
        knob.className = 'eq-fader-thumb';
        gainSlider.addEventListener('input', () => {
          band.gain = clampValue(Number(gainSlider.value), EQ_GAIN_RANGE.min, EQ_GAIN_RANGE.max);
          gainValue.textContent = `${band.gain.toFixed(1)} dB`;
          updateFaderThumbPosition(sliderWrap, gainSlider, knob);
          markEqDirty(nodeId);
          scheduleEqPush(nodeId);
        });
        sliderWrap.appendChild(gainSlider);
        sliderWrap.appendChild(knob);
        attachFaderPointerHandlers(sliderWrap, gainSlider);
        fader.appendChild(sliderWrap);
        fader.appendChild(gainValue);
        view.appendChild(fader);
      });
      container.appendChild(view);
      refreshFaderThumbs(view);
    }

    function refreshFaderThumbs(root = document) {
      const scope = root instanceof Element ? root : document;
      requestAnimationFrame(() => {
        scope.querySelectorAll('.eq-fader-slider').forEach(slider => {
          const wrap = slider.closest('.eq-fader-slider-wrap');
          const knob = wrap?.querySelector('.eq-fader-thumb');
          if (wrap && knob) {
            updateFaderThumbPosition(wrap, slider, knob);
          }
        });
      });
    }

    function updateFaderThumbPosition(wrap, slider, knob) {
      if (!wrap || !slider || !knob) return;
      const track = wrap.querySelector('.eq-fader-track');
      if (!track) return;
      const min = Number(slider.min);
      const max = Number(slider.max);
      const range = Math.max(1, max - min);
      const valueRatio = (Number(slider.value) - min) / range;
      const clampedRatio = clampValue(valueRatio, 0, 1);
      const trackTop = track.offsetTop;
      const trackHeight = track.offsetHeight;
      const y = trackTop + trackHeight - (trackHeight * clampedRatio);
      knob.style.setProperty('--fader-thumb-top', `${y}px`);
    }

    function attachFaderPointerHandlers(wrap, slider) {
      if (!wrap || !slider) return;
      const handleMove = (event) => {
        updateSliderValueFromPointer(event, wrap, slider);
      };
      const release = (event) => {
        wrap.classList.remove('is-dragging');
        wrap.removeEventListener('pointermove', handleMove);
        wrap.removeEventListener('pointerup', release);
        wrap.removeEventListener('pointercancel', release);
        wrap.releasePointerCapture?.(event.pointerId);
      };
      wrap.addEventListener('pointerdown', (event) => {
        if (event.button !== 0 && event.pointerType === 'mouse') return;
        event.preventDefault();
        slider.focus();
        wrap.classList.add('is-dragging');
        wrap.setPointerCapture?.(event.pointerId);
        updateSliderValueFromPointer(event, wrap, slider);
        wrap.addEventListener('pointermove', handleMove);
        wrap.addEventListener('pointerup', release);
        wrap.addEventListener('pointercancel', release);
      });
    }

    function updateSliderValueFromPointer(event, wrap, slider) {
      const track = wrap.querySelector('.eq-fader-track');
      const rect = (track || wrap).getBoundingClientRect();
      const height = rect.height || 1;
      const ratio = clampValue((rect.bottom - event.clientY) / height, 0, 1);
      const min = Number(slider.min);
      const max = Number(slider.max);
      const range = max - min;
      const step = slider.step && slider.step !== 'any' ? Number(slider.step) : null;
      let nextValue = min + ratio * range;
      if (step) {
        const steps = Math.round((nextValue - min) / step);
        nextValue = min + steps * step;
      }
      nextValue = clampValue(nextValue, min, max);
      const previous = Number(slider.value);
      if (Math.abs(previous - nextValue) < 1e-6) return;
      slider.value = formatSliderValue(nextValue, slider);
      slider.dispatchEvent(new Event('input', { bubbles: true }));
    }

    function formatSliderValue(value, slider) {
      const step = slider.step && slider.step !== 'any' ? Number(slider.step) : null;
      if (!step) return String(Math.round(value));
      const decimals = (step.toString().split('.')[1] || '').length;
      return value.toFixed(decimals);
    }

    window.addEventListener('resize', () => refreshFaderThumbs());


    function renderEqBands(nodeId, container) {
      const isFaderSkin = getEqSkin() === 'faders';
      container.classList.toggle('is-fader-view', isFaderSkin);
      if (isFaderSkin) {
        renderEqBandsFaders(nodeId, container);
      } else {
        renderEqBandsClassic(nodeId, container);
      }
    }

    function openEqModal(nodeId, nodeName) {
      const node = nodesCache.find(n => n.id === nodeId);
      if (node?.eq && !isEqDirty(nodeId)) {
        eqState[nodeId] = normalizeEqPayload(node.eq);
        markEqClean(nodeId);
      } else if (!eqState[nodeId]) {
        getEqState(nodeId);
        markEqClean(nodeId);
      }
      if (eqModal) eqModal.remove();
      eqModal = document.createElement('div');
      eqModal.className = 'settings-overlay';
      eqModal.style.display = 'flex';
      const card = document.createElement('div');
      card.className = 'settings-card';
      const header = document.createElement('div');
      header.className = 'settings-header';
      header.innerHTML = `<div class="section-title" style="margin:0;">EQ – ${nodeName}</div>`;
      const closeBtn = document.createElement('button');
      closeBtn.className = 'icon-btn';
      closeBtn.textContent = '✕';
      closeBtn.addEventListener('click', () => eqModal.remove());
      header.appendChild(closeBtn);
      card.appendChild(header);

      const controls = document.createElement('div');
      controls.className = 'eq-toolbar';
      const skinSelect = document.createElement('select');
      skinSelect.className = 'eq-skin-select';
      skinSelect.innerHTML = '<option value="classic">Detailed controls</option><option value="faders">Fader view</option>';
      skinSelect.value = getEqSkin();
      skinSelect.addEventListener('change', () => {
        setEqSkin(skinSelect.value);
        renderEqBands(nodeId, bandList);
      });
      const modeSelect = document.createElement('select');
      modeSelect.innerHTML = '<option value="peq15">15-band parametric</option><option value="peq31">31-band parametric</option>';
      modeSelect.value = getEqState(nodeId).mode;
      modeSelect.addEventListener('change', () => {
        setEqMode(nodeId, modeSelect.value);
        renderEqBands(nodeId, bandList);
        scheduleEqPush(nodeId);
      });
      const resetBtn = document.createElement('button');
      resetBtn.className = 'small-btn';
      resetBtn.textContent = 'Reset';
      resetBtn.addEventListener('click', () => {
        eqState[nodeId] = { mode: modeSelect.value, bands: defaultEqBands(modeSelect.value) };
        markEqDirty(nodeId);
        renderEqBands(nodeId, bandList);
        scheduleEqPush(nodeId);
      });
      const savePresetBtn = document.createElement('button');
      savePresetBtn.className = 'small-btn';
      savePresetBtn.textContent = 'Save preset';
      savePresetBtn.addEventListener('click', () => savePreset(nodeId, presetList, modeSelect, bandList));
      controls.appendChild(skinSelect);
      controls.appendChild(modeSelect);
      controls.appendChild(resetBtn);
      controls.appendChild(savePresetBtn);
      card.appendChild(controls);

      const bandList = document.createElement('div');
      bandList.className = 'eq-band-list';
      renderEqBands(nodeId, bandList);
      card.appendChild(bandList);

      const presetWrap = document.createElement('div');
      presetWrap.className = 'panel';
      presetWrap.style.marginTop = '12px';
      const presetTitle = document.createElement('div');
      presetTitle.className = 'section-title';
      presetTitle.innerText = 'Presets';
      presetWrap.appendChild(presetTitle);
      const presetList = document.createElement('div');
      presetList.id = 'preset-list';
      presetList.className = 'muted';
      presetWrap.appendChild(presetList);
      card.appendChild(presetWrap);

      eqModal.appendChild(card);
      document.body.appendChild(eqModal);
      renderPresets(nodeId, presetList, modeSelect, bandList);
    }

    function savePreset(nodeId, presetList, modeSelect, bandList) {
      const name = prompt('Preset name?');
      if (!name) return;
      const presets = JSON.parse(localStorage.getItem('eq-presets') || '{}');
      const state = getEqState(nodeId);
      presets[name] = { mode: state.mode, bands: state.bands.map(b => ({ ...b })) };
      localStorage.setItem('eq-presets', JSON.stringify(presets));
      renderPresets(nodeId, presetList, modeSelect, bandList);
      showSuccess('Preset saved');
    }

    function renderPresets(nodeId, container, modeSelect, bandList) {
      const presets = JSON.parse(localStorage.getItem('eq-presets') || '{}');
      const entries = Object.entries(presets);
      if (!entries.length) {
        container.innerHTML = 'No presets saved yet.';
        return;
      }
      container.innerHTML = '';
      entries.forEach(([name, data]) => {
        const row = document.createElement('div');
        row.className = 'node-actions';
        const label = document.createElement('div');
        label.textContent = name;
        const apply = document.createElement('button');
        apply.className = 'small-btn';
        apply.textContent = 'Apply';
        apply.addEventListener('click', () => {
          eqState[nodeId] = normalizeEqPayload(data);
          modeSelect.value = getEqState(nodeId).mode;
          markEqDirty(nodeId);
          renderEqBands(nodeId, bandList);
          scheduleEqPush(nodeId);
        });
        row.appendChild(label);
        row.appendChild(apply);
        container.appendChild(row);
      });
    }

    async function setMasterVolume(percent) {
      try {
        const res = await fetch('/api/snapcast/master-volume', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ percent: Number(percent) }),
        });
        await ensureOk(res);
      } catch (err) {
        showError(`Failed to set master volume: ${err.message}`);
      }
    }

    function msToTime(ms) {
      const total = Math.floor(ms / 1000);
      const m = Math.floor(total / 60);
      const s = String(total % 60).padStart(2, '0');
      return `${m}:${s}`;
    }

    async function fetchPlayerStatus() {
      try {
        const res = await fetch('/api/spotify/player/status');
        await ensureOk(res);
        playerStatus = await res.json();
        renderPlayer(playerStatus);
      } catch (err) {
        if (playerTick) {
          clearInterval(playerTick);
          playerTick = null;
        }
        playerStatus = null;
        playerPanel.style.display = 'flex';
        playerTitle.textContent = 'Player unavailable';
        playerArtist.textContent = '';
        playerSeek.disabled = true;
        playerTimeCurrent.textContent = '0:00';
        playerTimeTotal.textContent = '0:00';
        playerArt.style.display = 'none';
        setRangeProgress(playerSeek, 0, playerSeek.max || 1);
        setPlayButtonIcon(false);
        playerPrev.disabled = true;
        playerPlay.disabled = true;
        playerNext.disabled = true;
        if (playerShuffleBtn) playerShuffleBtn.disabled = true;
        if (playerRepeatBtn) playerRepeatBtn.disabled = true;
        setShuffleActive(false);
        setRepeatMode('off');
      }
    }

    function renderPlayer(status) {
      const item = status?.item || {};
      const active = !!status?.active;
      activeDeviceId = active && status?.device?.id ? status.device.id : null;
      playerPanel.style.display = 'flex';
      playerTitle.textContent = active ? (item.name || '—') : 'No active playback';
      const artists = (item.artists || []).map(a => a.name).join(', ');
      playerArtist.textContent = active ? (artists || '—') : '';
      const art = active ? (item.album?.images?.[1]?.url || item.album?.images?.[0]?.url) : null;
      if (art) {
        playerArt.src = art;
        playerArt.style.display = 'block';
      } else {
        playerArt.style.display = 'none';
      }
      lastCoverArtUrl = art || null;
      applyCoverArtBackground();
      const duration = item.duration_ms || 0;
      const progress = status?.progress_ms || 0;
      playerSeek.max = duration || 1;
      playerSeek.value = progress;
      setRangeProgress(playerSeek, progress, duration || 1);
      playerTimeCurrent.textContent = msToTime(progress);
      playerTimeTotal.textContent = msToTime(duration);
      const playing = !!status?.is_playing && active;
      setPlayButtonIcon(playing);
      playerPrev.disabled = !active;
      playerPlay.disabled = !active;
      playerNext.disabled = !active;
      playerSeek.disabled = !active;
      if (playerShuffleBtn) {
        playerShuffleBtn.disabled = !active;
        setShuffleActive(active && !!status?.shuffle_state);
      }
      if (playerRepeatBtn) {
        playerRepeatBtn.disabled = !active;
        setRepeatMode(active ? status?.repeat_state : 'off');
      }

      if (playerTick) {
        clearInterval(playerTick);
        playerTick = null;
      }
      if (active) {
        playerTick = setInterval(() => {
          if (!playerStatus || !playerStatus.is_playing) return;
          playerStatus.progress_ms = (playerStatus.progress_ms || 0) + 1000;
          if (playerStatus.progress_ms > (playerStatus.item?.duration_ms || 0)) {
            playerStatus.progress_ms = playerStatus.item?.duration_ms || 0;
          }
          const prog = playerStatus.progress_ms || 0;
          const dur = playerStatus.item?.duration_ms || 0;
          playerSeek.value = prog;
          setRangeProgress(playerSeek, prog, dur || 1);
          playerTimeCurrent.textContent = msToTime(prog);
          playerTimeTotal.textContent = msToTime(dur);
        }, 1000);
      }
    }

    function buildPlayerActionPath(path, body) {
      const hasDevice = body && typeof body === 'object' && Object.prototype.hasOwnProperty.call(body, 'device_id');
      if (hasDevice) return path;
      const deviceId = getActiveDeviceId();
      if (!deviceId) return path;
      const separator = path.includes('?') ? '&' : '?';
      return `${path}${separator}device_id=${encodeURIComponent(deviceId)}`;
    }

    async function playerAction(path, body) {
      try {
        const targetPath = buildPlayerActionPath(path, body);
        const res = await fetch(targetPath, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: body ? JSON.stringify(body) : undefined });
        await ensureOk(res);
        setTimeout(fetchPlayerStatus, 500);
      } catch (err) {
        showError(`Player action failed: ${err.message}`);
      }
    }

    async function startSpotifyAuth() {
      try {
        const res = await fetch('/api/spotify/auth-url');
        await ensureOk(res);
        const data = await res.json();
        if (data.url) window.open(data.url, '_blank');
      } catch (err) {
        showError(`Failed to start Spotify auth: ${err.message}`);
      }
    }


    async function registerNode() {
      try {
        await registerNodeWithName(nodeName.value || 'Node', nodeUrl.value);
        nodeName.value = '';
        nodeUrl.value = '';
      } catch (err) {
        showError(`Failed to register node: ${err.message}`);
      }
    }

    async function registerNodeWithName(name, url, btn, nodeId, fingerprint) {
      const normalizedUrl = normalizeNodeUrl(url);
      if (!normalizedUrl) {
        showError('Agent URL is required');
        return;
      }
      if (!nodeId && nodesCache.some(n => n.url === normalizedUrl)) {
        showSuccess('Node already registered');
        return;
      }
      if (btn) btn.disabled = true;
      const payload = { name, url: normalizedUrl };
      if (nodeId) payload.id = nodeId;
      if (fingerprint) payload.fingerprint = fingerprint;
      try {
        const res = await fetch('/api/nodes/register', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
        });
        await ensureOk(res);
        showSuccess(nodeId ? 'Node relinked' : 'Node registered');
        await fetchNodes();
      } finally {
        if (btn) btn.disabled = false;
      }
    }

    async function saveSpotify() {
      try {
        spotifySpinner.style.display = 'block';
        saveSpotifyBtn.disabled = true;
        const payload = {
          device_name: spName.value || 'RoomCast',
          bitrate: Number(spBitrate.value) || 320,
          initial_volume: Number(spInitVol.value) || 75,
          normalisation: spNormalise.checked,
          client_id: spClientId.value,
          client_secret: spClientSecret.value,
          redirect_uri: spRedirect.value || 'http://localhost:8000/api/spotify/callback',
        };
        if (!payload.client_secret) delete payload.client_secret;
        const res = await fetch('/api/config/spotify', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
        });
        await ensureOk(res);
        spClientSecret.value = '';
        showSuccess('Spotify config saved. Librespot will reload and connect.');
        await pollLibrespotStatus();
      } catch (err) {
        showError(`Failed to save Spotify config: ${err.message}`);
      } finally {
        saveSpotifyBtn.disabled = false;
        spotifySpinner.style.display = 'none';
      }
    }

    async function pollLibrespotStatus() {
      for (let i = 0; i < 8; i++) {
        await new Promise(r => setTimeout(r, 1200));
        await fetchLibrespotStatus();
        const text = librespotStatus.innerText || '';
        if (!text.includes('starting') && !text.includes('waiting') && !text.includes('unknown')) break;
      }
    }

    function openSettings() {
      settingsOverlay.style.display = 'flex';
      collapseAllPanels();
      syncGeneralSettingsUI();
      fetchSpotifyConfig();
      fetchLibrespotStatus();
      fetchStatus();
    }
    function closeSettings() { settingsOverlay.style.display = 'none'; }

    function openDiscover() {
      discoverOverlay.style.display = 'flex';
      discoverResultsCount = 0;
      discoverStatus.textContent = 'Ready to scan.';
      discoverList.innerHTML = '';
      discoverSpinner.style.display = 'none';
      startDiscoverBtn.disabled = false;
      startDiscoverBtn.textContent = 'Scan';
    }
    function closeDiscover() {
      if (discoverAbortController) {
        discoverAbortController.abort();
        discoverAbortController = null;
      }
      discoverSpinner.style.display = 'none';
      startDiscoverBtn.disabled = false;
      startDiscoverBtn.textContent = 'Scan';
      discoverOverlay.style.display = 'none';
    }

    startDiscoverBtn.addEventListener('click', discoverNodes);
    saveSpotifyBtn.addEventListener('click', saveSpotify);
    if (spInitVol) {
      spInitVol.addEventListener('input', () => setRangeProgress(spInitVol, spInitVol.value, spInitVol.max || 100));
    }
    openSettingsBtn.addEventListener('click', openSettings);
    closeSettingsBtn.addEventListener('click', closeSettings);
    closeDiscoverBtn.addEventListener('click', closeDiscover);
    if (coverArtBackgroundToggle) {
      coverArtBackgroundToggle.addEventListener('change', () => {
        setCoverArtBackgroundEnabled(coverArtBackgroundToggle.checked);
      });
    }
    const handleAddNodeKey = evt => {
      if (evt.key === 'Escape') {
        setAddNodeMenuOpen(false);
        addNodeToggle?.focus({ preventScroll: true });
      }
    };
    if (addNodeToggle) {
      addNodeToggle.addEventListener('click', evt => {
        evt.stopPropagation();
        const next = !addNodeContainer?.classList.contains('is-open');
        setAddNodeMenuOpen(next);
      });
      addNodeToggle.addEventListener('keydown', handleAddNodeKey);
    }
    if (addNodeMenu) {
      addNodeMenu.addEventListener('click', evt => evt.stopPropagation());
      addNodeMenu.addEventListener('keydown', handleAddNodeKey);
    }
    if (addHardwareNodeBtn) {
      addHardwareNodeBtn.addEventListener('click', () => {
        setAddNodeMenuOpen(false);
        openDiscover();
      });
    }
    if (createWebNodeBtn) {
      createWebNodeBtn.addEventListener('click', () => {
        setAddNodeMenuOpen(false);
        window.open('/web-node', '_blank');
      });
    }
    if (playerVolumeInline) {
      playerVolumeInline.addEventListener('click', evt => evt.stopPropagation());
    }
    if (playerVolumeToggle) {
      playerVolumeToggle.addEventListener('click', evt => {
        evt.stopPropagation();
        const next = !playerVolumeInline || !playerVolumeInline.classList.contains('is-open');
        setVolumeSliderOpen(next);
      });
    }
    const handleVolumeKey = evt => {
      if (evt.key === 'Escape') {
        setVolumeSliderOpen(false);
        playerVolumeToggle?.focus({ preventScroll: true });
      }
    };
    if (playerVolumeToggle) playerVolumeToggle.addEventListener('keydown', handleVolumeKey);
    if (masterVolume) {
      masterVolume.addEventListener('input', () => setRangeProgress(masterVolume, masterVolume.value, masterVolume.max || 100));
      masterVolume.addEventListener('change', () => setMasterVolume(masterVolume.value));
      masterVolume.addEventListener('keydown', handleVolumeKey);
    }
    document.addEventListener('click', evt => {
      if (playerVolumeInline && !playerVolumeInline.contains(evt.target)) {
        setVolumeSliderOpen(false);
      }
      if (addNodeContainer && !addNodeContainer.contains(evt.target)) {
        setAddNodeMenuOpen(false);
      }
    });
    playerPrev.addEventListener('click', () => {
      if (playerPrev.disabled) return;
      playerAction('/api/spotify/player/previous');
    });
    playerPlay.addEventListener('click', () => {
      if (playerPlay.disabled) return;
      if (playerStatus?.is_playing) playerAction('/api/spotify/player/pause');
      else playerAction('/api/spotify/player/play');
    });
    playerNext.addEventListener('click', () => {
      if (playerNext.disabled) return;
      playerAction('/api/spotify/player/next');
    });
    playerSeek.addEventListener('input', () => setRangeProgress(playerSeek, playerSeek.value, playerSeek.max || 1));
    playerSeek.addEventListener('change', () => playerAction('/api/spotify/player/seek', { position_ms: Number(playerSeek.value) }));
    playerShuffleBtn.addEventListener('click', () => {
      if (playerShuffleBtn.disabled) return;
      const current = typeof playerStatus?.shuffle_state === 'boolean'
        ? playerStatus.shuffle_state
        : playerShuffleBtn.classList.contains('is-active');
      const payload = { state: !current };
      const deviceId = getActiveDeviceId();
      if (deviceId) payload.device_id = deviceId;
      playerAction('/api/spotify/player/shuffle', payload);
    });
    playerRepeatBtn.addEventListener('click', () => {
      if (playerRepeatBtn.disabled) return;
      const current = playerStatus?.repeat_state || playerRepeatBtn.dataset.mode || 'off';
      const next = current === 'off' ? 'context' : current === 'context' ? 'track' : 'off';
      const payload = { mode: next };
      const deviceId = getActiveDeviceId();
      if (deviceId) payload.device_id = deviceId;
      playerAction('/api/spotify/player/repeat', payload);
    });
    spotifyAuthBtn.addEventListener('click', startSpotifyAuth);
    spotifyDashboardBtn.addEventListener('click', () => window.open('https://developer.spotify.com/dashboard', '_blank'));

    const NODE_REFRESH_MS = 4000;
    fetchNodes();
    fetchStatus();
    fetchPlayerStatus();
    setInterval(fetchNodes, NODE_REFRESH_MS);
    setInterval(fetchPlayerStatus, 4000);
  </script>
</body>
</html>
