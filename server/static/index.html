<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>RoomCast</title>
  <style>
    :root {
      color-scheme: dark;
      font-family: "Inter", system-ui, -apple-system, sans-serif;
      background: #0b1020;
      color: #e2e8f0;
    }
    * { box-sizing: border-box; }
    body { margin: 0; padding: 0; background: radial-gradient(circle at 20% 20%, rgba(34,197,94,0.08), transparent 30%), radial-gradient(circle at 80% 0%, rgba(59,130,246,0.08), transparent 25%), #0b1020; }
    .shell { max-width: 960px; margin: 0 auto; padding: 16px 16px 64px; }
    header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; }
    h1 { margin: 0; font-size: 22px; letter-spacing: -0.4px; }
    .icon-btn { background: rgba(255,255,255,0.07); color: #e2e8f0; border: 1px solid rgba(255,255,255,0.12); padding: 8px 10px; border-radius: 12px; cursor: pointer; font-weight: 700; min-width: 44px; }
    .panel { background: rgba(255, 255, 255, 0.04); border: 1px solid rgba(255, 255, 255, 0.08); border-radius: 16px; padding: 16px; margin-bottom: 16px; box-shadow: 0 14px 36px rgba(0,0,0,0.3); }
    .section-title { font-size: 14px; text-transform: uppercase; letter-spacing: 1px; color: #94a3b8; margin: 0 0 10px; }
    .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap: 12px; }
    label { display: block; font-size: 13px; color: #cbd5e1; margin-bottom: 6px; }
    input, select, textarea { width: 100%; border-radius: 12px; border: 1px solid rgba(255,255,255,0.12); background: rgba(255,255,255,0.06); color: #e2e8f0; padding: 10px 12px; font-size: 14px; }
    textarea { min-height: 64px; }
    .muted { opacity: 0.7; }
    .label { font-size: 13px; color: #cbd5e1; margin-top: 6px; }
    .toast { position: fixed; top: 16px; left: 50%; transform: translate(-50%, -8px); min-width: 240px; max-width: 90vw; z-index: 1000; transition: opacity 0.2s ease, transform 0.2s ease; }
    .error { background: #fecdd3; color: #7f1d1d; padding: 12px; border-radius: 12px; box-shadow: 0 15px 30px rgba(0,0,0,0.35); }
    .success { background: rgba(34,197,94,0.14); color: #bbf7d0; padding: 12px; border-radius: 12px; box-shadow: 0 15px 30px rgba(0,0,0,0.35); }
    input[type=range] { accent-color: #22c55e; }
    button { background: linear-gradient(135deg, #22c55e, #16a34a); color: #0b1020; border: none; padding: 10px 14px; border-radius: 12px; cursor: pointer; font-weight: 700; width: 100%; transition: transform 0.08s ease, filter 0.12s ease; }
    button:active { transform: translateY(1px) scale(0.99); filter: brightness(0.95); }
    .small-btn { width: auto; padding: 8px 12px; }
    .node-header { display: flex; justify-content: space-between; align-items: center; gap: 8px; }
    .node-gear { position: relative; }
    .node-menu { position: absolute; top: calc(100% + 6px); right: 0; background: rgba(15,23,42,0.95); border: 1px solid rgba(255,255,255,0.08); border-radius: 12px; padding: 8px; display: none; flex-direction: column; gap: 6px; min-width: 180px; box-shadow: 0 18px 40px rgba(0,0,0,0.45); z-index: 20; }
    .node-menu button { width: 100%; }
    .node-actions { display: flex; gap: 8px; align-items: center; margin-top: 8px; }
    .node-status { font-size: 12px; color: #cbd5e1; margin-top: 6px; display: flex; align-items: center; gap: 10px; }
    .status-pill { padding: 2px 8px; border-radius: 999px; font-size: 11px; letter-spacing: 0.4px; text-transform: uppercase; }
    .status-pill.ok { background: rgba(34,197,94,0.18); color: #bbf7d0; }
    .status-pill.warn { background: rgba(249,115,22,0.18); color: #fed7aa; }
    .eq-block { margin-top: 10px; }
    .eq-band-list { max-height: 70vh; overflow-y: auto; margin-top: 12px; }
    .eq-band-row { display: grid; grid-template-columns: 56px 1fr 1fr 1fr; gap: 12px; padding: 8px 0; border-bottom: 1px solid rgba(255,255,255,0.05); }
    .eq-band-row:last-child { border-bottom: none; }
    .eq-band-label { font-size: 12px; color: rgba(255,255,255,0.5); align-self: center; }
    .eq-band-cell label { font-size: 11px; text-transform: uppercase; display: block; margin-bottom: 4px; color: rgba(255,255,255,0.5); }
    .eq-band-cell input[type="number"] { width: 100%; margin-bottom: 4px; }
    .eq-band-cell input[type="range"] { width: 100%; }
    .settings-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.6); display: none; align-items: flex-start; justify-content: center; overflow-y: auto; padding: 24px 12px; }
    .settings-card { background: #0f172a; border: 1px solid rgba(255,255,255,0.08); border-radius: 18px; padding: 16px; width: min(960px, 95vw); box-shadow: 0 18px 40px rgba(0,0,0,0.35); }
    .settings-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; }
    .spinner { width: 18px; height: 18px; border: 3px solid rgba(255,255,255,0.2); border-top-color: #22c55e; border-radius: 50%; animation: spin 0.8s linear infinite; display: inline-block; vertical-align: middle; }
    @keyframes spin { to { transform: rotate(360deg); } }
    @media (max-width: 640px) {
      header { flex-direction: row; }
      .node-actions { flex-wrap: wrap; }
    }
  </style>
</head>
<body>
  <div class="shell">
    <header>
      <h1>RoomCast</h1>
      <div style="display:flex; gap:8px;">
        <button id="refresh" class="icon-btn">⟳</button>
        <button id="new-web-node" class="icon-btn">New web node</button>
        <button id="open-settings" class="icon-btn">⚙︎</button>
      </div>
    </header>

    <div id="error" class="toast error" style="display:none; opacity:0;"></div>
    <div id="success" class="toast success" style="display:none; opacity:0;"></div>

    <div class="panel" id="master-panel">
      <div class="section-title">Master volume</div>
      <input type="range" id="master-volume" min="0" max="100" value="75">
    </div>

    <div class="panel" id="player-panel">
      <div class="section-title">Now playing</div>
      <div style="display:flex; gap:12px; align-items:center; flex-wrap:wrap;">
        <img id="player-art" src="" alt="" style="width:64px; height:64px; border-radius:10px; object-fit:cover; background:#111; display:none;">
        <div style="flex:1; min-width:200px;">
          <div id="player-title" style="font-weight:700;">—</div>
          <div id="player-artist" class="muted">—</div>
        </div>
        <button class="small-btn" id="player-prev">⏮︎</button>
        <button class="small-btn" id="player-play">⏯</button>
        <button class="small-btn" id="player-next">⏭︎</button>
      </div>
      <div style="margin-top:10px;">
        <input type="range" id="player-seek" min="0" max="100" value="0">
        <div class="muted" id="player-time" style="font-size:12px; margin-top:4px;">0:00 / 0:00</div>
      </div>
    </div>

    <div class="panel">
      <div class="section-title">Nodes</div>
      <div class="node-actions">
        <button id="discover-nodes" class="small-btn">Discover nodes</button>
        <button id="refresh-nodes" class="small-btn">Refresh nodes</button>
      </div>
      <div id="nodes" style="margin-top:12px;"></div>
    </div>

  </div>

  <div id="settings-overlay" class="settings-overlay">
    <div class="settings-card">
      <div class="settings-header">
        <div class="section-title" style="margin:0;">Settings</div>
        <button id="close-settings" class="icon-btn">✕</button>
      </div>
      <div class="panel">
        <div class="section-title">Spotify setup</div>
        <div class="muted" id="librespot-status" style="margin-bottom:8px;">Status: unknown</div>
        <div class="grid">
          <div>
            <label>Username</label>
            <input id="sp-username" placeholder="user@example.com" autocomplete="off">
          </div>
          <div>
            <label>Password</label>
            <input id="sp-password" type="password" placeholder="••••••••">
          </div>
          <div>
            <label>Spotify client ID</label>
            <input id="sp-client-id" placeholder="client id">
          </div>
          <div>
            <label>Spotify client secret</label>
            <input id="sp-client-secret" type="password" placeholder="client secret">
          </div>
          <div>
            <label>Redirect URI</label>
            <input id="sp-redirect" placeholder="http://localhost:8000/api/spotify/callback">
          </div>
          <div>
            <label>Device name</label>
            <input id="sp-name" placeholder="RoomCast">
          </div>
          <div>
            <label>Bitrate</label>
            <select id="sp-bitrate">
              <option value="96">96 kbps</option>
              <option value="160">160 kbps</option>
              <option value="320" selected>320 kbps</option>
            </select>
          </div>
          <div>
            <label>Initial volume</label>
            <input id="sp-initvol" type="range" min="0" max="100" value="75">
          </div>
          <div style="display:flex; align-items:center; gap:6px;">
            <label style="margin:0;">Volume normalisation</label>
            <input id="sp-normalise" type="checkbox" style="width:auto;">
          </div>
      </div>
        <div style="margin-top:12px;">
          <button id="save-spotify">Save Spotify config</button>
          <div id="spotify-spinner" style="display:none; margin-top:8px;"><span class="spinner"></span> <span class="muted">Saving & restarting…</span></div>
          <div style="margin-top:8px;">
          <button class="small-btn" id="spotify-auth">Link Spotify account</button>
          <button class="small-btn" id="spotify-dashboard">Open Spotify developer dashboard</button>
          <div class="muted" style="font-size:12px;">Use dashboard to create Client ID/Secret, then Save and Link.</div>
          </div>
        </div>
      </div>

      <div class="panel">
        <div class="section-title">Snapcast clients (view)</div>
        <div id="clients-settings"></div>
      </div>

    </div>
  </div>

  <div id="discover-overlay" class="settings-overlay">
    <div class="settings-card">
      <div class="settings-header">
        <div class="section-title" style="margin:0;">Discover nodes</div>
        <button id="close-discover" class="icon-btn">✕</button>
      </div>
      <div style="display:flex; gap:12px; align-items:center; justify-content:space-between; flex-wrap:wrap; margin-bottom:8px;">
        <div class="muted" style="flex:1; min-width:200px;">Scans all available networks and streams results live.</div>
        <button id="start-discover" class="small-btn" style="min-width:120px;">Scan</button>
      </div>
      <div id="discover-spinner" style="margin-bottom:8px; display:none;"><span class="spinner"></span> <span class="muted">Scanning...</span></div>
      <div id="discover-status" class="muted">Ready to scan.</div>
      <div id="discover-list"></div>
    </div>
  </div>

  <script>
    const nodesEl = document.getElementById('nodes');
    const clientsSettingsEl = document.getElementById('clients-settings');
    const errorEl = document.getElementById('error');
    const successEl = document.getElementById('success');
    const refreshBtn = document.getElementById('refresh');
    const refreshNodesBtn = document.getElementById('refresh-nodes');
    const discoverBtn = document.getElementById('discover-nodes');
    const saveSpotifyBtn = document.getElementById('save-spotify');
    const spUsername = document.getElementById('sp-username');
    const spPassword = document.getElementById('sp-password');
    const spClientId = document.getElementById('sp-client-id');
    const spClientSecret = document.getElementById('sp-client-secret');
    const spRedirect = document.getElementById('sp-redirect');
    const spName = document.getElementById('sp-name');
    const spBitrate = document.getElementById('sp-bitrate');
    const spInitVol = document.getElementById('sp-initvol');
    const spNormalise = document.getElementById('sp-normalise');
    const nodeName = document.getElementById('node-name');
    const nodeUrl = document.getElementById('node-url');
    const librespotStatus = document.getElementById('librespot-status');
    const settingsOverlay = document.getElementById('settings-overlay');
    const openSettingsBtn = document.getElementById('open-settings');
    const newWebNodeBtn = document.getElementById('new-web-node');
    const closeSettingsBtn = document.getElementById('close-settings');
    const spotifySpinner = document.getElementById('spotify-spinner');
    const discoverOverlay = document.getElementById('discover-overlay');
    const closeDiscoverBtn = document.getElementById('close-discover');
    const discoverSpinner = document.getElementById('discover-spinner');
    const discoverStatus = document.getElementById('discover-status');
    const discoverList = document.getElementById('discover-list');
    const startDiscoverBtn = document.getElementById('start-discover');
    const masterVolume = document.getElementById('master-volume');
    const playerPanel = document.getElementById('player-panel');
    const playerPrev = document.getElementById('player-prev');
    const playerPlay = document.getElementById('player-play');
    const playerNext = document.getElementById('player-next');
    const playerSeek = document.getElementById('player-seek');
    const playerTime = document.getElementById('player-time');
    const playerArt = document.getElementById('player-art');
    const playerTitle = document.getElementById('player-title');
    const playerArtist = document.getElementById('player-artist');
    let playerStatus = null;
    let playerTick = null;
    const eqOverlay = document.createElement('div');
    let discoverAbortController = null;
    let discoverResultsCount = 0;
    let openNodeMenu = null;
    let openNodeMenuId = null;

    function hideNodeMenu(options = {}) {
      if (openNodeMenu) {
        openNodeMenu.style.display = 'none';
      }
      openNodeMenu = null;
      if (!options.preserveId) {
        openNodeMenuId = null;
      }
    }

    document.addEventListener('click', () => hideNodeMenu());

    function clearMessages() {
      errorEl.style.display = 'none';
      successEl.style.display = 'none';
    }

    const toastQueue = [];
    let toastActive = false;

    function showToast(el, msg, timeout = 3500) {
      el.innerText = msg;
      el.style.display = 'block';
      el.style.opacity = '1';
      el.style.transform = 'translateY(0)';
      setTimeout(() => {
        el.style.opacity = '0';
        el.style.transform = 'translateY(-8px)';
        setTimeout(() => {
          el.style.display = 'none';
        }, 200);
      }, timeout);
    }

    function enqueueToast(el, msg, timeout) {
      toastQueue.push({ el, msg, timeout });
      if (!toastActive) runToastQueue();
    }

    function runToastQueue() {
      if (!toastQueue.length) {
        toastActive = false;
        return;
      }
      toastActive = true;
      const { el, msg, timeout } = toastQueue.shift();
      showToast(el, msg, timeout);
      setTimeout(runToastQueue, (timeout || 3500) + 250);
    }

    function showError(msg) {
      enqueueToast(errorEl, msg, 4500);
    }

    function showSuccess(msg) {
      enqueueToast(successEl, msg, 3000);
    }

    async function ensureOk(res, fallback) {
      if (res.ok) return res;
      let detail = fallback || `HTTP ${res.status}`;
      try {
        const text = await res.text();
        if (text) {
          try {
            const parsed = JSON.parse(text);
            if (parsed?.detail) detail = parsed.detail;
            else if (parsed?.message) detail = parsed.message;
            else detail = text;
          } catch (_) {
            detail = text;
          }
        }
      } catch (_) {
        /* ignore body parse errors */
      }
      throw new Error(detail);
    }

    function describePan(value) {
      const num = typeof value === 'number' ? value : Number(value);
      if (Number.isNaN(num) || Math.abs(num) < 0.01) return 'Center';
      const pct = Math.round(Math.abs(num) * 100);
      return num > 0 ? `Right ${pct}%` : `Left ${pct}%`;
    }

    function applyMuteButtonState(btn, muted) {
      const active = !!muted;
      btn.dataset.muted = active ? 'true' : 'false';
      btn.textContent = active ? 'Unmute' : 'Mute';
      btn.style.background = active ? 'linear-gradient(135deg, #f59e0b, #d97706)' : '';
    }

    let nodesCache = [];
    const eqState = {};
    const eqUpdateTimers = {};
    const camillaPendingNodes = {};
    const EQ_FREQUENCIES = {
      peq15: [25, 40, 63, 100, 160, 250, 400, 630, 1000, 1600, 2500, 4000, 6300, 10000, 16000],
      peq31: [20, 25, 31.5, 40, 50, 63, 80, 100, 125, 160, 200, 250, 315, 400, 500, 630, 800, 1000, 1250, 1600, 2000, 2500, 3150, 4000, 5000, 6300, 8000, 10000, 12500, 16000, 20000],
    };
    const EQ_GAIN_RANGE = { min: -12, max: 12 };
    const EQ_Q_RANGE = { min: 0.2, max: 10 };
    const EQ_PUSH_DEBOUNCE_MS = 120;
    const LOG_FREQ = { min: Math.log10(20), max: Math.log10(20000) };
    let eqModal = null;
    const spotifyAuthBtn = document.getElementById('spotify-auth');
    const spotifyDashboardBtn = document.getElementById('spotify-dashboard');

    function renderNodes(nodes) {
      nodesCache = nodes;
      const reopenMenuNodeId = openNodeMenuId;
      hideNodeMenu({ preserveId: true });
      nodesEl.innerHTML = '';
      if (!nodes.length) {
        nodesEl.innerHTML = '<div class="muted">No nodes registered yet.</div>';
        Object.keys(camillaPendingNodes).forEach(id => delete camillaPendingNodes[id]);
        return;
      }
      nodes.forEach(n => {
        hydrateEqFromNode(n);
        const wrapper = document.createElement('div');
        wrapper.className = 'panel';
        const header = document.createElement('div');
        header.className = 'node-header';
        const title = document.createElement('div');
        title.innerHTML = `<strong>${n.name}</strong>`;
        header.appendChild(title);

        const gearWrap = document.createElement('div');
        gearWrap.className = 'node-gear';
        const gearBtn = document.createElement('button');
        gearBtn.className = 'icon-btn small-btn';
        gearBtn.textContent = '⚙︎';
        const gearMenu = document.createElement('div');
        gearMenu.className = 'node-menu';
        gearMenu.addEventListener('click', (event) => event.stopPropagation());
        const addMenuButton = (label, handler) => {
          const btn = document.createElement('button');
          btn.className = 'small-btn';
          btn.textContent = label;
          btn.addEventListener('click', (event) => {
            event.stopPropagation();
            hideNodeMenu();
            if (typeof handler === 'function') handler(btn);
          });
          gearMenu.appendChild(btn);
          return btn;
        };
        gearBtn.addEventListener('click', (event) => {
          event.stopPropagation();
          if (openNodeMenu === gearMenu) {
            hideNodeMenu();
            return;
          }
          hideNodeMenu();
          gearMenu.style.display = 'flex';
          openNodeMenu = gearMenu;
          openNodeMenuId = n.id;
        });
        gearWrap.appendChild(gearBtn);
        gearWrap.appendChild(gearMenu);
        addMenuButton('Rename', () => renameNode(n.id, n.name));
        header.appendChild(gearWrap);
        wrapper.appendChild(header);
        if (reopenMenuNodeId && reopenMenuNodeId === n.id) {
          gearMenu.style.display = 'flex';
          openNodeMenu = gearMenu;
          openNodeMenuId = n.id;
        }

        const statusRow = document.createElement('div');
        statusRow.className = 'node-status';
        const isBrowser = n.type === 'browser';
        const paired = !!n.paired;
        const configured = isBrowser ? true : !!n.configured;
        const restarting = !!n.restarting;
        const updateAvailable = n.update_available !== false;
        const updating = !!n.updating;
        const outputInfo = n.outputs || {};
        const outputOptions = Array.isArray(outputInfo.options) ? outputInfo.options : [];
        const selectedOutput = outputInfo.selected || n.playback_device || '';
        const disableAgentControls = !isBrowser && (!paired || !configured || restarting);
        const typePill = document.createElement('span');
        typePill.className = `status-pill ${isBrowser || paired ? 'ok' : 'warn'}`;
        typePill.textContent = isBrowser ? 'Browser node' : paired ? 'Paired' : 'Pairing required';
        statusRow.appendChild(typePill);
        if (!isBrowser) {
          const cfgPill = document.createElement('span');
          cfgPill.className = `status-pill ${configured ? 'ok' : 'warn'}`;
          cfgPill.textContent = configured ? 'Audio ready' : 'Needs config';
          statusRow.appendChild(cfgPill);
        }
        const urlMeta = document.createElement('div');
        urlMeta.className = 'muted';
        urlMeta.textContent = n.url;
        statusRow.appendChild(urlMeta);
        if (!isBrowser) {
          const versionMeta = document.createElement('div');
          versionMeta.className = 'label';
          if (n.agent_version) {
            let suffix = '';
            if (updating) suffix = ' (updating…)';
            else if (!updateAvailable) suffix = ' (latest)';
            versionMeta.textContent = `Agent ${n.agent_version}${suffix}`;
          } else {
            versionMeta.textContent = 'Agent version unknown';
          }
          statusRow.appendChild(versionMeta);
        }
        if (restarting) {
          const restartPill = document.createElement('span');
          restartPill.className = 'status-pill warn';
          restartPill.textContent = 'Restarting';
          statusRow.appendChild(restartPill);
        }
        if (updating) {
          const updatingPill = document.createElement('span');
          updatingPill.className = 'status-pill warn';
          updatingPill.textContent = 'Updating';
          statusRow.appendChild(updatingPill);
        }
        wrapper.appendChild(statusRow);

        const volRow = document.createElement('div');
        volRow.style.display = 'grid';
        volRow.style.gridTemplateColumns = 'auto minmax(0, 1fr)';
        volRow.style.alignItems = 'center';
        volRow.style.gap = '8px';
        const muteBtn = document.createElement('button');
        muteBtn.className = 'small-btn';
        muteBtn.textContent = 'Mute';
        muteBtn.disabled = disableAgentControls;
        muteBtn.addEventListener('click', () => toggleMute(n.id, muteBtn));
        applyMuteButtonState(muteBtn, n.muted === true);
        volRow.appendChild(muteBtn);
        const volInput = document.createElement('input');
        volInput.type = 'range';
        volInput.min = 0;
        volInput.max = 100;
        const parsedVolume = Number(n.volume_percent);
        volInput.value = Number.isFinite(parsedVolume) ? parsedVolume : 75;
        volInput.disabled = disableAgentControls;
        volInput.style.width = '100%';
        volInput.addEventListener('change', () => setNodeVolume(n.id, volInput.value));
        volRow.appendChild(volInput);
        wrapper.appendChild(volRow);

        if (!isBrowser) {
          const outputWrap = document.createElement('div');
          outputWrap.style.marginTop = '8px';
          const outputLabel = document.createElement('div');
          outputLabel.className = 'label';
          outputLabel.innerText = 'Audio output';
          const outputSelect = document.createElement('select');
          outputSelect.style.width = '100%';
          outputSelect.disabled = disableAgentControls || updating || !outputOptions.length;
          const mappedOptions = [...outputOptions];
          if (selectedOutput && !mappedOptions.some(opt => opt.id === selectedOutput)) {
            mappedOptions.unshift({ id: selectedOutput, label: `${selectedOutput} (current)` });
          }
          mappedOptions.forEach(opt => {
            const optionEl = document.createElement('option');
            optionEl.value = opt.id;
            optionEl.textContent = opt.label || opt.id;
            outputSelect.appendChild(optionEl);
          });
          if (selectedOutput) {
            outputSelect.value = selectedOutput;
          }
          outputSelect.addEventListener('change', () => {
            if (!outputSelect.value) return;
            setNodeOutput(n.id, outputSelect.value, outputSelect);
          });
          outputWrap.appendChild(outputLabel);
          if (!mappedOptions.length) {
            const emptyLabel = document.createElement('div');
            emptyLabel.className = 'muted';
            emptyLabel.innerText = 'No outputs detected';
            outputWrap.appendChild(emptyLabel);
          } else {
            outputWrap.appendChild(outputSelect);
          }
          wrapper.appendChild(outputWrap);
        }

        if (n.type === 'browser') {
          const panLabel = document.createElement('div');
          panLabel.className = 'label';
          let currentPan = typeof n.pan === 'number' ? n.pan : 0;
          panLabel.innerText = `Pan – ${describePan(currentPan)}`;
          wrapper.appendChild(panLabel);

          const panInput = document.createElement('input');
          panInput.type = 'range';
          panInput.min = -100;
          panInput.max = 100;
          panInput.step = 2;
          panInput.value = Math.round(currentPan * 100);
          panInput.addEventListener('input', () => {
            const nextPan = Number(panInput.value) / 100;
            panLabel.innerText = `Pan – ${describePan(nextPan)}`;
          });
          panInput.addEventListener('change', async () => {
            const nextPan = Math.max(-1, Math.min(1, Number(panInput.value) / 100));
            try {
              await setNodePan(n.id, nextPan);
              currentPan = nextPan;
            } catch (err) {
              panInput.value = Math.round(currentPan * 100);
              panLabel.innerText = `Pan – ${describePan(currentPan)}`;
            }
          });
          wrapper.appendChild(panInput);
        }

        const actions = document.createElement('div');
        actions.className = 'node-actions';
        const eqBtn = document.createElement('button');
        eqBtn.className = 'small-btn';
        eqBtn.textContent = 'EQ';
        eqBtn.disabled = n.type !== 'browser' && (!paired || !configured || restarting);
        eqBtn.addEventListener('click', () => openEqModal(n.id, n.name));
        actions.appendChild(eqBtn);
        if (n.type !== 'browser') {
          const pairBtn = addMenuButton(paired ? 'Rotate key' : 'Pair node', (btn) => pairNode(n.id, btn));
          pairBtn.disabled = restarting;
          if (!paired) {
            pairBtn.style.background = 'linear-gradient(135deg, #f97316, #ea580c)';
          }
          const configBtn = addMenuButton(configured ? 'Reconfigure audio' : 'Configure audio', (btn) => configureNode(n.id, btn));
          configBtn.disabled = !paired || restarting;
          if (!configured) {
            configBtn.style.background = 'linear-gradient(135deg, #22c55e, #16a34a)';
          }
          const restartBtn = addMenuButton(restarting ? 'Restarting…' : 'Restart node', (btn) => restartNode(n.id, btn));
          restartBtn.disabled = !paired || restarting;
          const checkBtn = addMenuButton('Check for updates', (btn) => checkNodeUpdates(n.id, btn));
          checkBtn.disabled = !paired || restarting || updating;
          if (updateAvailable) {
            const updateBtn = document.createElement('button');
            updateBtn.className = 'small-btn';
            updateBtn.textContent = updating ? 'Updating…' : 'Update node';
            updateBtn.disabled = !paired || restarting || updating;
            if (!updating) {
              updateBtn.addEventListener('click', () => updateNode(n.id, updateBtn));
            }
            actions.appendChild(updateBtn);
          }
        }
        const removeBtn = addMenuButton('Unregister', () => unregisterNode(n.id));
        removeBtn.style.background = 'linear-gradient(135deg, #ef4444, #dc2626)';
        wrapper.appendChild(actions);

        nodesEl.appendChild(wrapper);
      });

      const nodeIds = new Set(nodes.map(n => n.id));
      Object.keys(camillaPendingNodes).forEach(id => {
        if (!nodeIds.has(id)) delete camillaPendingNodes[id];
      });
      if (reopenMenuNodeId && !openNodeMenu) {
        openNodeMenuId = null;
      }
    }

    function renderClients(groups, target) {
      target.innerHTML = '';
      groups.forEach(group => {
        group.clients.forEach(c => {
          const panel = document.createElement('div');
          panel.style.marginBottom = '10px';
          const row = document.createElement('div');
          row.style.display = 'grid';
          row.style.gridTemplateColumns = '1fr 120px';
          row.style.gap = '12px';
          row.style.alignItems = 'center';
          const label = document.createElement('div');
          label.innerHTML = `<div>${c.friendlyName || c.id}</div><div class="label">${group.stream?.name || 'Spotify'}</div>`;
          const input = document.createElement('input');
          input.type = 'range';
          input.min = 0;
          input.max = 100;
          input.value = c.config?.volume?.percent ?? 50;
          input.addEventListener('change', () => setVolume(c.id, input.value));
          row.appendChild(label);
          row.appendChild(input);
          panel.appendChild(row);
          target.appendChild(panel);
        });
      });
      if (!groups.length) {
        target.innerHTML = '<div class="muted">No clients connected yet.</div>';
      }
    }

    function appendDiscovered(items) {
      const list = Array.isArray(items) ? items : [items];
      list.forEach(item => {
        if (!item || !item.url) return;
        const row = document.createElement('div');
        row.className = 'panel discover-row';
        row.style.marginBottom = '8px';
        const title = document.createElement('div');
        const versionLabel = item.version ? `Agent ${item.version}` : 'Version unknown';
        title.innerHTML = `<strong>${item.host}</strong> <span class="muted">${item.url}</span><div class="label">${versionLabel}</div>`;
        const nameInput = document.createElement('input');
        nameInput.value = `Node ${item.host}`;
        nameInput.style.marginTop = '6px';
        const btn = document.createElement('button');
        btn.className = 'small-btn';
        btn.textContent = 'Register';
        btn.style.marginTop = '6px';
        btn.addEventListener('click', () => registerNodeWithName(nameInput.value, item.url, btn));
        row.appendChild(title);
        row.appendChild(nameInput);
        row.appendChild(btn);
        discoverList.appendChild(row);
      });
    }

    async function fetchStatus() {
      try {
        clearMessages();
        const res = await fetch('/api/snapcast/status');
        await ensureOk(res);
        const data = await res.json();
        renderClients(data.server?.groups || [], clientsSettingsEl);
      } catch (err) {
        showError(`Failed to fetch snapcast status: ${err.message}`);
      }
    }

    async function fetchNodes() {
      try {
        const res = await fetch('/api/nodes');
        await ensureOk(res);
        const data = await res.json();
        renderNodes(data.nodes || []);
      } catch (err) {
        showError(`Failed to load nodes: ${err.message}`);
      }
    }

    async function fetchSpotifyConfig() {
      try {
        const res = await fetch('/api/config/spotify');
        await ensureOk(res);
        const cfg = await res.json();
        spUsername.value = cfg.username || '';
        spName.value = cfg.device_name || 'RoomCast';
        spBitrate.value = cfg.bitrate || 320;
        spInitVol.value = cfg.initial_volume ?? 75;
        spNormalise.checked = cfg.normalisation ?? true;
        spClientId.value = cfg.client_id || '';
        spRedirect.value = cfg.redirect_uri || '';
        if (cfg.has_password) spPassword.placeholder = 'stored';
        if (cfg.has_client_secret) spClientSecret.placeholder = 'stored';
      } catch (err) {
        showError(`Failed to load Spotify config: ${err.message}`);
      }
    }

    async function fetchLibrespotStatus() {
      try {
        const res = await fetch('/api/librespot/status');
        await ensureOk(res);
        const data = await res.json();
        librespotStatus.innerText = `Status: ${data.state || 'unknown'}${data.message ? ' – ' + data.message : ''}`;
      } catch (err) {
        librespotStatus.innerText = `Failed to load status: ${err.message}`;
      }
    }

    async function discoverNodes() {
      if (discoverAbortController) {
        discoverAbortController.abort();
        discoverAbortController = null;
      }
      discoverResultsCount = 0;
      discoverList.innerHTML = '';
      discoverStatus.textContent = 'Preparing scan…';
      discoverSpinner.style.display = 'block';
      startDiscoverBtn.disabled = true;
      startDiscoverBtn.textContent = 'Scanning…';
      discoverAbortController = new AbortController();
      const decoder = new TextDecoder();
      let buffer = '';

      const processLine = (line) => {
        if (!line) return;
        let payload;
        try {
          payload = JSON.parse(line);
        } catch (err) {
          return;
        }
        if (payload.type === 'start') {
          const nets = Array.isArray(payload.networks) && payload.networks.length ? payload.networks.join(', ') : 'detected networks';
          const limited = payload.limited ? ' (limited – narrow networks for deeper scan)' : '';
          discoverStatus.textContent = `Scanning ${nets} (${payload.host_count ?? '?'} hosts)${limited}.`;
          return;
        }
        if (payload.type === 'discovered') {
          if (discoverResultsCount === 0) {
            discoverList.innerHTML = '';
          }
          discoverResultsCount += 1;
          appendDiscovered(payload.data);
          discoverStatus.textContent = `Found ${discoverResultsCount} node${discoverResultsCount === 1 ? '' : 's'} so far…`;
          return;
        }
        if (payload.type === 'complete') {
          discoverStatus.textContent = payload.found ? `Scan complete – ${payload.found} node${payload.found === 1 ? '' : 's'} found.` : 'Scan complete – no nodes responded.';
          return;
        }
        if (payload.type === 'cancelled') {
          discoverStatus.textContent = `Scan cancelled after ${payload.found || discoverResultsCount} result${(payload.found || discoverResultsCount) === 1 ? '' : 's'}.`;
          return;
        }
        if (payload.type === 'error') {
          discoverStatus.textContent = `Discovery error: ${payload.message || 'unknown error'}`;
        }
      };

      try {
        const res = await fetch('/api/nodes/discover', { signal: discoverAbortController.signal });
        await ensureOk(res);
        if (!res.body) throw new Error('Streaming not supported in this browser');
        const reader = res.body.getReader();
        while (true) {
          const { value, done } = await reader.read();
          if (done) break;
          buffer += decoder.decode(value, { stream: true });
          let idx = buffer.indexOf('\n');
          while (idx >= 0) {
            const line = buffer.slice(0, idx).trim();
            buffer = buffer.slice(idx + 1);
            processLine(line);
            idx = buffer.indexOf('\n');
          }
        }
        const tail = buffer.trim();
        if (tail) processLine(tail);
      } catch (err) {
        if (err.name === 'AbortError') {
          discoverStatus.textContent = 'Scan cancelled.';
        } else {
          discoverStatus.textContent = `Failed to discover: ${err.message}`;
        }
      } finally {
        discoverSpinner.style.display = 'none';
        startDiscoverBtn.disabled = false;
        startDiscoverBtn.textContent = 'Scan';
        discoverAbortController = null;
        if (!discoverResultsCount && discoverList.children.length === 0) {
          discoverList.innerHTML = '<div class="muted">No agents found yet. Ensure nodes run on the same subnet and respond on port 9700.</div>';
        }
      }
    }

    async function setVolume(clientId, percent) {
      try {
        const res = await fetch(`/api/snapcast/clients/${clientId}/volume`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ percent: Number(percent) }),
        });
        await ensureOk(res);
      } catch (err) {
        showError(`Failed to set volume: ${err.message}`);
      }
    }

    async function setNodeVolume(nodeId, percent) {
      try {
        const res = await fetch(`/api/nodes/${nodeId}/volume`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ percent: Number(percent) }),
        });
        await ensureOk(res);
        showSuccess('Node volume updated');
      } catch (err) {
        showError(`Failed to set node volume: ${err.message}`);
      }
    }

    async function setNodePan(nodeId, pan) {
      const clamped = Math.max(-1, Math.min(1, Number(pan)));
      try {
        const res = await fetch(`/api/nodes/${nodeId}/pan`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ pan: clamped }),
        });
        await ensureOk(res);
        showSuccess('Web node pan updated');
      } catch (err) {
        showError(`Failed to set pan: ${err.message}`);
        throw err;
      }
    }

    async function toggleMute(nodeId, btn) {
      const currentlyMuted = btn.dataset.muted === 'true';
      btn.disabled = true;
      try {
        const res = await fetch(`/api/nodes/${nodeId}/mute`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ muted: !currentlyMuted }),
        });
        await ensureOk(res);
        const data = await res.json();
        const muted = data?.result?.muted ?? !currentlyMuted;
        applyMuteButtonState(btn, muted);
      } catch (err) {
        showError(`Failed to toggle mute: ${err.message}`);
      } finally {
        btn.disabled = false;
      }
    }

    async function pairNode(nodeId, btn) {
      if (btn) btn.disabled = true;
      try {
        const res = await fetch(`/api/nodes/${nodeId}/pair`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ force: true }),
        });
        await ensureOk(res);
        showSuccess('Node paired');
        await fetchNodes();
      } catch (err) {
        showError(`Failed to pair node: ${err.message}`);
      } finally {
        if (btn) btn.disabled = false;
      }
    }

    async function renameNode(nodeId, currentName) {
      const nextName = prompt('Rename node', currentName || 'Node');
      if (nextName === null) return;
      const trimmed = nextName.trim();
      if (!trimmed) {
        showError('Node name cannot be empty');
        return;
      }
      try {
        const res = await fetch(`/api/nodes/${nodeId}/rename`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name: trimmed }),
        });
        await ensureOk(res);
        showSuccess('Node renamed');
        await fetchNodes();
      } catch (err) {
        showError(`Failed to rename node: ${err.message}`);
      }
    }

    async function configureNode(nodeId, btn) {
      if (btn) btn.disabled = true;
      try {
        const res = await fetch(`/api/nodes/${nodeId}/configure`, { method: 'POST' });
        await ensureOk(res);
        showSuccess('Node audio configured');
        await fetchNodes();
      } catch (err) {
        showError(`Failed to configure node: ${err.message}`);
      } finally {
        if (btn) btn.disabled = false;
      }
    }

    async function setNodeOutput(nodeId, deviceId, selectEl) {
      if (!deviceId) return;
      const originalValue = selectEl ? selectEl.value : null;
      if (selectEl) selectEl.disabled = true;
      try {
        const res = await fetch(`/api/nodes/${nodeId}/outputs`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ device: deviceId }),
        });
        await ensureOk(res);
        showSuccess('Audio output updated');
        await fetchNodes();
      } catch (err) {
        showError(`Failed to set output: ${err.message}`);
        if (selectEl && originalValue !== null) {
          selectEl.value = originalValue;
        }
      } finally {
        if (selectEl) selectEl.disabled = false;
      }
    }

    async function checkNodeUpdates(nodeId, btn) {
      const originalLabel = btn ? btn.textContent : '';
      if (btn) {
        btn.disabled = true;
        btn.textContent = 'Checking…';
      }
      try {
        const res = await fetch(`/api/nodes/${nodeId}/check-updates`, { method: 'POST' });
        await ensureOk(res);
        const data = await res.json().catch(() => ({}));
        if (data?.update_available) {
          showSuccess('Update available for this node.');
        } else {
          showSuccess('Node is up to date.');
        }
        await fetchNodes();
      } catch (err) {
        showError(`Failed to check updates: ${err.message}`);
      } finally {
        if (btn) {
          btn.disabled = false;
          btn.textContent = originalLabel || 'Check for updates';
        }
      }
    }

    async function updateNode(nodeId, btn) {
      const originalLabel = btn ? btn.textContent : '';
      let failed = false;
      if (btn) {
        btn.disabled = true;
        btn.textContent = 'Updating…';
      }
      try {
        const res = await fetch(`/api/nodes/${nodeId}/update`, { method: 'POST' });
        await ensureOk(res);
        showSuccess('Node update triggered. Agent will restart shortly.');
        fetchNodes();
        setTimeout(fetchNodes, 15000);
      } catch (err) {
        showError(`Failed to update node: ${err.message}`);
        failed = true;
      } finally {
        if (btn && failed) {
          btn.disabled = false;
          btn.textContent = originalLabel || 'Update node';
        }
      }
    }

    async function restartNode(nodeId, btn) {
      if (btn) {
        btn.disabled = true;
        btn.textContent = 'Restarting…';
      }
      try {
        const res = await fetch(`/api/nodes/${nodeId}/restart`, { method: 'POST' });
        await ensureOk(res);
        showSuccess('Node restart requested');
        await fetchNodes();
      } catch (err) {
        showError(`Failed to restart node: ${err.message}`);
        if (btn) {
          btn.disabled = false;
          btn.textContent = 'Restart node';
        }
      }
    }

    async function unregisterNode(nodeId) {
      try {
        const res = await fetch(`/api/nodes/${nodeId}`, { method: 'DELETE' });
        await ensureOk(res);
        showSuccess('Node unregistered');
        await fetchNodes();
      } catch (err) {
        showError(`Failed to unregister node: ${err.message}`);
      }
    }

    function clampValue(val, min, max) {
      return Math.min(max, Math.max(min, val));
    }

    function defaultEqBands(mode) {
      const freqs = EQ_FREQUENCIES[mode] || EQ_FREQUENCIES.peq15;
      return freqs.map(freq => ({ freq, gain: 0, q: 1 }));
    }

    function normalizeEqPayload(payload) {
      if (!payload) return { mode: 'peq15', bands: defaultEqBands('peq15') };
      const sourceBands = Array.isArray(payload.bands) ? payload.bands : [];
      const mode = (payload.preset === 'peq31' || Number(payload.band_count) >= 31) ? 'peq31' : 'peq15';
      const template = defaultEqBands(mode);
      template.forEach((band, idx) => {
        const src = sourceBands[idx];
        if (!src) return;
        band.freq = clampValue(Number(src.freq) || band.freq, 20, 20000);
        band.gain = clampValue(Number(src.gain) || 0, EQ_GAIN_RANGE.min, EQ_GAIN_RANGE.max);
        band.q = clampValue(Number(src.q) || 1, EQ_Q_RANGE.min, EQ_Q_RANGE.max);
      });
      return { mode, bands: template };
    }

    function hydrateEqFromNode(node) {
      if (!node || !node.id) return;
      eqState[node.id] = normalizeEqPayload(node.eq);
    }

    function getEqState(nodeId) {
      if (!eqState[nodeId]) {
        eqState[nodeId] = { mode: 'peq15', bands: defaultEqBands('peq15') };
      }
      return eqState[nodeId];
    }

    function setEqMode(nodeId, mode) {
      const target = EQ_FREQUENCIES[mode] ? mode : 'peq15';
      const nextBands = defaultEqBands(target);
      const current = getEqState(nodeId).bands;
      nextBands.forEach((band, idx) => {
        if (current[idx]) {
          band.freq = clampValue(current[idx].freq, 20, 20000);
          band.gain = clampValue(current[idx].gain, EQ_GAIN_RANGE.min, EQ_GAIN_RANGE.max);
          band.q = clampValue(current[idx].q, EQ_Q_RANGE.min, EQ_Q_RANGE.max);
        }
      });
      eqState[nodeId] = { mode: target, bands: nextBands };
    }

    function freqToSlider(freq) {
      const logF = Math.log10(clampValue(freq, 20, 20000));
      const ratio = (logF - LOG_FREQ.min) / (LOG_FREQ.max - LOG_FREQ.min);
      return Math.round(ratio * 1000);
    }

    function sliderToFreq(value) {
      const ratio = clampValue(value, 0, 1000) / 1000;
      const logF = LOG_FREQ.min + ratio * (LOG_FREQ.max - LOG_FREQ.min);
      return Math.pow(10, logF);
    }

    function scheduleEqPush(nodeId) {
      clearTimeout(eqUpdateTimers[nodeId]);
      eqUpdateTimers[nodeId] = setTimeout(() => pushEq(nodeId), EQ_PUSH_DEBOUNCE_MS);
    }

    function handleCamillaPending(nodeId, pending) {
      const prev = camillaPendingNodes[nodeId] || false;
      camillaPendingNodes[nodeId] = pending;
      if (prev === pending) return;
      const node = nodesCache.find(n => n.id === nodeId);
      const label = node?.name || 'Node';
      if (pending) {
        showError(`${label}: EQ queued until DSP is available`);
      } else {
        showSuccess(`${label}: EQ applied after DSP recovery`);
      }
    }

    async function pushEq(nodeId) {
      const state = getEqState(nodeId);
      const payload = {
        preset: state.mode,
        band_count: state.bands.length,
        bands: state.bands.map(b => ({
          freq: Number(b.freq),
          gain: Number(b.gain),
          q: Number(b.q),
        })),
      };
      try {
        const res = await fetch(`/api/nodes/${nodeId}/eq`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
        });
        await ensureOk(res);
        let data = null;
        try {
          data = await res.json();
        } catch (_) {
          data = null;
        }
        const pending = !!data?.result?.camilla_pending;
        handleCamillaPending(nodeId, pending);
      } catch (err) {
        showError(`Failed to update EQ: ${err.message}`);
      }
    }

    function renderEqBands(nodeId, container) {
      const state = getEqState(nodeId);
      container.innerHTML = '';
      state.bands.forEach((band, idx) => {
        const row = document.createElement('div');
        row.className = 'eq-band-row';

        const label = document.createElement('div');
        label.className = 'eq-band-label';
        label.textContent = `#${idx + 1}`;
        row.appendChild(label);

        const freqCell = document.createElement('div');
        freqCell.className = 'eq-band-cell';
        const freqLabel = document.createElement('label');
        freqLabel.textContent = 'Freq (Hz)';
        const freqInput = document.createElement('input');
        freqInput.type = 'number';
        freqInput.min = 20;
        freqInput.max = 20000;
        freqInput.value = Math.round(band.freq);
        freqInput.addEventListener('change', () => {
          band.freq = clampValue(Number(freqInput.value) || band.freq, 20, 20000);
          freqSlider.value = freqToSlider(band.freq);
          scheduleEqPush(nodeId);
        });
        const freqSlider = document.createElement('input');
        freqSlider.type = 'range';
        freqSlider.min = 0;
        freqSlider.max = 1000;
        freqSlider.value = freqToSlider(band.freq);
        freqSlider.addEventListener('input', () => {
          band.freq = clampValue(sliderToFreq(Number(freqSlider.value)), 20, 20000);
          freqInput.value = Math.round(band.freq);
          scheduleEqPush(nodeId);
        });
        freqCell.appendChild(freqLabel);
        freqCell.appendChild(freqInput);
        freqCell.appendChild(freqSlider);
        row.appendChild(freqCell);

        const gainCell = document.createElement('div');
        gainCell.className = 'eq-band-cell';
        const gainLabel = document.createElement('label');
        gainLabel.textContent = 'Gain (dB)';
        const gainSlider = document.createElement('input');
        gainSlider.type = 'range';
        gainSlider.min = EQ_GAIN_RANGE.min;
        gainSlider.max = EQ_GAIN_RANGE.max;
        gainSlider.step = 0.5;
        gainSlider.value = band.gain;
        const gainValue = document.createElement('div');
        gainValue.className = 'muted';
        gainValue.textContent = `${band.gain.toFixed(1)} dB`;
        gainSlider.addEventListener('input', () => {
          band.gain = clampValue(Number(gainSlider.value), EQ_GAIN_RANGE.min, EQ_GAIN_RANGE.max);
          gainValue.textContent = `${band.gain.toFixed(1)} dB`;
          scheduleEqPush(nodeId);
        });
        gainCell.appendChild(gainLabel);
        gainCell.appendChild(gainSlider);
        gainCell.appendChild(gainValue);
        row.appendChild(gainCell);

        const qCell = document.createElement('div');
        qCell.className = 'eq-band-cell';
        const qLabel = document.createElement('label');
        qLabel.textContent = 'Q';
        const qInput = document.createElement('input');
        qInput.type = 'number';
        qInput.step = 0.1;
        qInput.min = EQ_Q_RANGE.min;
        qInput.max = EQ_Q_RANGE.max;
        qInput.value = band.q.toFixed(2);
        qInput.addEventListener('change', () => {
          band.q = clampValue(Number(qInput.value) || band.q, EQ_Q_RANGE.min, EQ_Q_RANGE.max);
          scheduleEqPush(nodeId);
        });
        qCell.appendChild(qLabel);
        qCell.appendChild(qInput);
        row.appendChild(qCell);

        container.appendChild(row);
      });
    }

    function openEqModal(nodeId, nodeName) {
      const node = nodesCache.find(n => n.id === nodeId);
      if (node?.eq) {
        eqState[nodeId] = normalizeEqPayload(node.eq);
      } else {
        getEqState(nodeId);
      }
      if (eqModal) eqModal.remove();
      eqModal = document.createElement('div');
      eqModal.className = 'settings-overlay';
      eqModal.style.display = 'flex';
      const card = document.createElement('div');
      card.className = 'settings-card';
      const header = document.createElement('div');
      header.className = 'settings-header';
      header.innerHTML = `<div class="section-title" style="margin:0;">EQ – ${nodeName}</div>`;
      const closeBtn = document.createElement('button');
      closeBtn.className = 'icon-btn';
      closeBtn.textContent = '✕';
      closeBtn.addEventListener('click', () => eqModal.remove());
      header.appendChild(closeBtn);
      card.appendChild(header);

      const controls = document.createElement('div');
      controls.className = 'node-actions';
      const modeSelect = document.createElement('select');
      modeSelect.innerHTML = '<option value="peq15">15-band parametric</option><option value="peq31">31-band parametric</option>';
      modeSelect.value = getEqState(nodeId).mode;
      modeSelect.addEventListener('change', () => {
        setEqMode(nodeId, modeSelect.value);
        renderEqBands(nodeId, bandList);
        scheduleEqPush(nodeId);
      });
      const resetBtn = document.createElement('button');
      resetBtn.className = 'small-btn';
      resetBtn.textContent = 'Reset';
      resetBtn.addEventListener('click', () => {
        eqState[nodeId] = { mode: modeSelect.value, bands: defaultEqBands(modeSelect.value) };
        renderEqBands(nodeId, bandList);
        scheduleEqPush(nodeId);
      });
      const savePresetBtn = document.createElement('button');
      savePresetBtn.className = 'small-btn';
      savePresetBtn.textContent = 'Save preset';
      savePresetBtn.addEventListener('click', () => savePreset(nodeId, presetList, modeSelect, bandList));
      controls.appendChild(modeSelect);
      controls.appendChild(resetBtn);
      controls.appendChild(savePresetBtn);
      card.appendChild(controls);

      const bandList = document.createElement('div');
      bandList.className = 'eq-band-list';
      renderEqBands(nodeId, bandList);
      card.appendChild(bandList);

      const presetWrap = document.createElement('div');
      presetWrap.className = 'panel';
      presetWrap.style.marginTop = '12px';
      const presetTitle = document.createElement('div');
      presetTitle.className = 'section-title';
      presetTitle.innerText = 'Presets';
      presetWrap.appendChild(presetTitle);
      const presetList = document.createElement('div');
      presetList.id = 'preset-list';
      presetList.className = 'muted';
      presetWrap.appendChild(presetList);
      card.appendChild(presetWrap);

      eqModal.appendChild(card);
      document.body.appendChild(eqModal);
      renderPresets(nodeId, presetList, modeSelect, bandList);
    }

    function savePreset(nodeId, presetList, modeSelect, bandList) {
      const name = prompt('Preset name?');
      if (!name) return;
      const presets = JSON.parse(localStorage.getItem('eq-presets') || '{}');
      const state = getEqState(nodeId);
      presets[name] = { mode: state.mode, bands: state.bands.map(b => ({ ...b })) };
      localStorage.setItem('eq-presets', JSON.stringify(presets));
      renderPresets(nodeId, presetList, modeSelect, bandList);
      showSuccess('Preset saved');
    }

    function renderPresets(nodeId, container, modeSelect, bandList) {
      const presets = JSON.parse(localStorage.getItem('eq-presets') || '{}');
      const entries = Object.entries(presets);
      if (!entries.length) {
        container.innerHTML = 'No presets saved yet.';
        return;
      }
      container.innerHTML = '';
      entries.forEach(([name, data]) => {
        const row = document.createElement('div');
        row.className = 'node-actions';
        const label = document.createElement('div');
        label.textContent = name;
        const apply = document.createElement('button');
        apply.className = 'small-btn';
        apply.textContent = 'Apply';
        apply.addEventListener('click', () => {
          eqState[nodeId] = normalizeEqPayload(data);
          modeSelect.value = getEqState(nodeId).mode;
          renderEqBands(nodeId, bandList);
          scheduleEqPush(nodeId);
        });
        row.appendChild(label);
        row.appendChild(apply);
        container.appendChild(row);
      });
    }

    async function setMasterVolume(percent) {
      try {
        const res = await fetch('/api/snapcast/master-volume', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ percent: Number(percent) }),
        });
        await ensureOk(res);
      } catch (err) {
        showError(`Failed to set master volume: ${err.message}`);
      }
    }

    function msToTime(ms) {
      const total = Math.floor(ms / 1000);
      const m = Math.floor(total / 60);
      const s = String(total % 60).padStart(2, '0');
      return `${m}:${s}`;
    }

    async function fetchPlayerStatus() {
      try {
        const res = await fetch('/api/spotify/player/status');
        await ensureOk(res);
        playerStatus = await res.json();
        renderPlayer(playerStatus);
      } catch (err) {
        playerPanel.style.display = 'block';
        playerTitle.textContent = 'Player unavailable';
        playerArtist.textContent = '';
        playerSeek.disabled = true;
      }
    }

    function renderPlayer(status) {
      const item = status?.item || {};
      const active = status?.active;
      playerPanel.style.display = 'block';
      playerTitle.textContent = active ? (item.name || '—') : 'No active playback';
      const artists = (item.artists || []).map(a => a.name).join(', ');
      playerArtist.textContent = active ? (artists || '—') : '';
      const art = active ? (item.album?.images?.[1]?.url || item.album?.images?.[0]?.url) : null;
      if (art) {
        playerArt.src = art;
        playerArt.style.display = 'block';
      } else {
        playerArt.style.display = 'none';
      }
      const duration = item.duration_ms || 0;
      const progress = status?.progress_ms || 0;
      playerSeek.max = duration || 1;
      playerSeek.value = progress;
      playerTime.textContent = `${msToTime(progress)} / ${msToTime(duration)}`;
      const playing = !!status?.is_playing;
      playerPlay.textContent = playing ? '⏸' : '▶';
      playerPrev.disabled = !active;
      playerPlay.disabled = !active;
      playerNext.disabled = !active;
      playerSeek.disabled = !active;

      if (playerTick) clearInterval(playerTick);
      if (active) {
        playerTick = setInterval(() => {
          if (!playerStatus || !playerStatus.is_playing) return;
          playerStatus.progress_ms = (playerStatus.progress_ms || 0) + 1000;
          if (playerStatus.progress_ms > (playerStatus.item?.duration_ms || 0)) {
            playerStatus.progress_ms = playerStatus.item?.duration_ms || 0;
          }
          const prog = playerStatus.progress_ms || 0;
          const dur = playerStatus.item?.duration_ms || 0;
          playerSeek.value = prog;
          playerTime.textContent = `${msToTime(prog)} / ${msToTime(dur)}`;
        }, 1000);
      }
    }

    async function playerAction(path, body) {
      try {
        const res = await fetch(path, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: body ? JSON.stringify(body) : undefined });
        await ensureOk(res);
        setTimeout(fetchPlayerStatus, 500);
      } catch (err) {
        showError(`Player action failed: ${err.message}`);
      }
    }

    async function startSpotifyAuth() {
      try {
        const res = await fetch('/api/spotify/auth-url');
        await ensureOk(res);
        const data = await res.json();
        if (data.url) window.open(data.url, '_blank');
      } catch (err) {
        showError(`Failed to start Spotify auth: ${err.message}`);
      }
    }


    async function registerNode() {
      try {
        await registerNodeWithName(nodeName.value || 'Node', nodeUrl.value);
        nodeName.value = '';
        nodeUrl.value = '';
      } catch (err) {
        showError(`Failed to register node: ${err.message}`);
      }
    }

    async function registerNodeWithName(name, url, btn) {
      const normalizedUrl = (url || '').replace(/\/+$/, '');
      if (!normalizedUrl) {
        showError('Agent URL is required');
        return;
      }
      if (nodesCache.some(n => n.url === normalizedUrl)) {
        showSuccess('Node already registered');
        return;
      }
      if (btn) btn.disabled = true;
      const payload = { name, url: normalizedUrl };
      try {
        const res = await fetch('/api/nodes/register', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
        });
        await ensureOk(res);
        showSuccess('Node registered');
        await fetchNodes();
      } finally {
        if (btn) btn.disabled = false;
      }
    }

    async function saveSpotify() {
      try {
        spotifySpinner.style.display = 'block';
        saveSpotifyBtn.disabled = true;
        const payload = {
          username: spUsername.value,
          password: spPassword.value,
          device_name: spName.value || 'RoomCast',
          bitrate: Number(spBitrate.value),
          initial_volume: Number(spInitVol.value),
          normalisation: spNormalise.checked,
          client_id: spClientId.value,
          client_secret: spClientSecret.value,
          redirect_uri: spRedirect.value || 'http://localhost:8000/api/spotify/callback',
        };
        if (!payload.password) delete payload.password;
        if (!payload.client_secret) delete payload.client_secret;
        const res = await fetch('/api/config/spotify', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
        });
        await ensureOk(res);
        spPassword.value = '';
        showSuccess('Spotify config saved. Librespot will reload and connect.');
        await pollLibrespotStatus();
      } catch (err) {
        showError(`Failed to save Spotify config: ${err.message}`);
      } finally {
        saveSpotifyBtn.disabled = false;
        spotifySpinner.style.display = 'none';
      }
    }

    async function pollLibrespotStatus() {
      for (let i = 0; i < 8; i++) {
        await new Promise(r => setTimeout(r, 1200));
        await fetchLibrespotStatus();
        const text = librespotStatus.innerText || '';
        if (!text.includes('starting') && !text.includes('waiting') && !text.includes('unknown')) break;
      }
    }

    function openSettings() {
      settingsOverlay.style.display = 'flex';
      fetchSpotifyConfig();
      fetchLibrespotStatus();
      fetchStatus();
    }
    function closeSettings() { settingsOverlay.style.display = 'none'; }

    function openDiscover() {
      discoverOverlay.style.display = 'flex';
      discoverResultsCount = 0;
      discoverStatus.textContent = 'Ready to scan.';
      discoverList.innerHTML = '';
      discoverSpinner.style.display = 'none';
      startDiscoverBtn.disabled = false;
      startDiscoverBtn.textContent = 'Scan';
    }
    function closeDiscover() {
      if (discoverAbortController) {
        discoverAbortController.abort();
        discoverAbortController = null;
      }
      discoverSpinner.style.display = 'none';
      startDiscoverBtn.disabled = false;
      startDiscoverBtn.textContent = 'Scan';
      discoverOverlay.style.display = 'none';
    }

    refreshBtn.addEventListener('click', () => { fetchNodes(); fetchStatus(); });
    refreshNodesBtn.addEventListener('click', fetchNodes);
    discoverBtn.addEventListener('click', openDiscover);
    startDiscoverBtn.addEventListener('click', discoverNodes);
    saveSpotifyBtn.addEventListener('click', saveSpotify);
    openSettingsBtn.addEventListener('click', openSettings);
    closeSettingsBtn.addEventListener('click', closeSettings);
    closeDiscoverBtn.addEventListener('click', closeDiscover);
    masterVolume.addEventListener('change', () => setMasterVolume(masterVolume.value));
    playerPrev.addEventListener('click', () => playerAction('/api/spotify/player/previous'));
    playerPlay.addEventListener('click', () => {
      if (playerStatus?.is_playing) playerAction('/api/spotify/player/pause');
      else playerAction('/api/spotify/player/play');
    });
    playerNext.addEventListener('click', () => playerAction('/api/spotify/player/next'));
    playerSeek.addEventListener('change', () => playerAction('/api/spotify/player/seek', { position_ms: Number(playerSeek.value) }));
    spotifyAuthBtn.addEventListener('click', startSpotifyAuth);
    spotifyDashboardBtn.addEventListener('click', () => window.open('https://developer.spotify.com/dashboard', '_blank'));
    newWebNodeBtn.addEventListener('click', () => window.open('/web-node', '_blank'));

    const NODE_REFRESH_MS = 4000;
    fetchNodes();
    fetchStatus();
    fetchPlayerStatus();
    setInterval(fetchNodes, NODE_REFRESH_MS);
    setInterval(fetchPlayerStatus, 4000);
  </script>
</body>
</html>
