<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>RoomCast Web Node</title>
  <style>
    body { background:#0b1020; color:#e2e8f0; font-family: system-ui, -apple-system, sans-serif; padding:24px; }
    .panel { background: rgba(255,255,255,0.04); border:1px solid rgba(255,255,255,0.08); border-radius:16px; padding:16px; max-width:640px; margin:auto; box-shadow:0 14px 36px rgba(0,0,0,0.3); }
    label { display:block; margin-bottom:6px; color:#cbd5e1; }
    input { width:100%; padding:10px 12px; border-radius:12px; border:1px solid rgba(255,255,255,0.12); background:rgba(255,255,255,0.06); color:#e2e8f0; }
    button { margin-top:10px; padding:10px 14px; border:none; border-radius:12px; background:linear-gradient(135deg,#22c55e,#16a34a); color:#0b1020; font-weight:700; cursor:pointer; width:100%; }
    .muted { color:#94a3b8; font-size:14px; }
  </style>
</head>
<body>
  <div class="panel">
    <div style="display:flex; justify-content: space-between; align-items:center;">
      <h2 style="margin:0;">Web Node</h2>
      <button onclick="window.location.href='/'" style="width:auto;">Back to Home</button>
    </div>
    <p class="muted">This is experimental. It plays the Snapserver stream in your browser and registers as a node.</p>
    <div id="register-block">
      <label>Node name</label>
      <input id="node-name" placeholder="Browser node">
      <button id="register">Start web node</button>
    </div>
    <button id="disconnect" style="width:100%; margin-top:10px; display:none; background:linear-gradient(135deg,#ef4444,#dc2626);">Disconnect</button>
    <div id="status" class="muted" style="margin-top:8px;">Idle</div>
    <div style="margin-top:8px;">
      <label>Node volume</label>
      <input id="node-volume" type="range" min="0" max="100" value="75" disabled>
    </div>
    <audio id="player" controls autoplay style="margin-top:12px; width:100%;" crossorigin="anonymous"></audio>
  </div>
  <script>
    const nameInput = document.getElementById('node-name');
    const registerBtn = document.getElementById('register');
    const disconnectBtn = document.getElementById('disconnect');
    const statusEl = document.getElementById('status');
    const audio = document.getElementById('player');
    const nodeVol = document.getElementById('node-volume');
    const registerBlock = document.getElementById('register-block');

    let nodeId = null;
    let pc = null;
    let ws = null;

    function setStatus(message) {
      statusEl.textContent = message;
    }

    function wsUrl(id) {
      const proto = window.location.protocol === 'https:' ? 'wss://' : 'ws://';
      return `${proto}${window.location.host}/ws/web-node?node_id=${encodeURIComponent(id)}`;
    }

    async function waitForIce(connection, timeoutMs = 2500) {
      if (connection.iceGatheringState === 'complete') return;
      await new Promise(resolve => {
        const timer = setTimeout(() => {
          connection.removeEventListener('icegatheringstatechange', check);
          resolve();
        }, timeoutMs);
        function check() {
          if (connection.iceGatheringState === 'complete') {
            clearTimeout(timer);
            connection.removeEventListener('icegatheringstatechange', check);
            resolve();
          }
        }
        connection.addEventListener('icegatheringstatechange', check);
      });
    }

    async function startWebNode() {
      if (pc) {
        setStatus('Already connected. Disconnect first.');
        return;
      }
      registerBtn.disabled = true;
      setStatus('Connectingâ€¦');
      try {
        const name = nameInput.value.trim() || 'Browser node';
        pc = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });
        pc.ontrack = (event) => {
          const [stream] = event.streams;
          audio.srcObject = stream;
          audio.play().catch(() => {});
          nodeVol.disabled = false;
        };
        pc.onconnectionstatechange = () => {
          if (!pc) return;
          if (['disconnected', 'failed'].includes(pc.connectionState)) {
            setStatus('Connection lost');
            disconnect(false);
          }
        };

        const offer = await pc.createOffer({ offerToReceiveAudio: true });
        await pc.setLocalDescription(offer);
        await waitForIce(pc);

        const res = await fetch('/api/web-nodes/session', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            name,
            sdp: pc.localDescription?.sdp,
            type: pc.localDescription?.type,
          }),
        });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json();
        nodeId = data.node.id;
        await pc.setRemoteDescription({ type: data.answer_type, sdp: data.answer });
        await connectControlSocket();
        registerBlock.style.display = 'none';
        disconnectBtn.style.display = 'block';
        disconnectBtn.disabled = false;
        setStatus(`Connected as ${data.node.name}`);
      } catch (err) {
        console.error(err);
        setStatus(`Failed to connect: ${err.message}`);
        await cleanupLocal();
      } finally {
        registerBtn.disabled = false;
      }
    }

    async function connectControlSocket() {
      if (!nodeId) return;
      ws = new WebSocket(wsUrl(nodeId));
      ws.onmessage = (evt) => {
        try {
          const msg = JSON.parse(evt.data);
          handleControlMessage(msg);
        } catch (err) {
          console.warn('Invalid control message', err);
        }
      };
      ws.onclose = () => {
        if (nodeId) {
          setStatus('Control channel closed');
          disconnect(false);
        }
      };
    }

    function handleControlMessage(msg) {
      if (msg.type === 'volume') {
        const percent = Math.max(0, Math.min(100, msg.percent ?? 0));
        audio.volume = percent / 100;
        nodeVol.value = percent;
        setStatus(`Volume ${percent}%`);
      } else if (msg.type === 'mute') {
        audio.muted = !!msg.muted;
        setStatus(msg.muted ? 'Muted' : 'Playing');
      } else if (msg.type === 'session' && msg.state === 'ended') {
        setStatus('Session ended by controller');
        disconnect(false);
      }
    }

    async function disconnect(manual = true) {
      if (!nodeId) {
        await cleanupLocal();
        return;
      }
      disconnectBtn.disabled = true;
      try {
        if (manual) {
          await fetch(`/api/nodes/${nodeId}`, { method: 'DELETE' });
        }
      } catch (err) {
        console.warn('Failed to unregister node', err);
      } finally {
        await cleanupLocal();
        setStatus(manual ? 'Disconnected' : 'Idle');
      }
    }

    async function cleanupLocal() {
      if (ws) {
        ws.onclose = null;
        ws.close();
        ws = null;
      }
      if (pc) {
        pc.onconnectionstatechange = null;
        pc.getSenders().forEach(sender => sender.track?.stop());
        pc.close();
        pc = null;
      }
      nodeId = null;
      audio.pause();
      audio.srcObject = null;
      audio.currentTime = 0;
      nodeVol.disabled = true;
      nodeVol.value = 75;
      registerBlock.style.display = 'block';
      disconnectBtn.style.display = 'none';
    }

    registerBtn.addEventListener('click', startWebNode);
    disconnectBtn.addEventListener('click', () => disconnect(true));
    nodeVol.addEventListener('input', () => { audio.volume = nodeVol.value / 100; });
  </script>
</body>
</html>
