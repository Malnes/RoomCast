<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>RoomCast Web Node</title>
  <style>
    *, *::before, *::after { box-sizing: border-box; }
    :root { --channel-accent:#22c55e; }
    body { background:#0b1020; color:#e2e8f0; font-family: system-ui, -apple-system, sans-serif; padding:24px; }
    .panel { background: rgba(255,255,255,0.04); border:1px solid rgba(255,255,255,0.08); border-radius:16px; padding:16px; max-width:640px; margin:auto; box-shadow:0 14px 36px rgba(0,0,0,0.3); }
    label { display:block; margin-bottom:6px; color:#cbd5e1; }
    input { width:100%; padding:10px 12px; border-radius:12px; border:1px solid rgba(255,255,255,0.12); background:rgba(255,255,255,0.06); color:#e2e8f0; }
    input[type="range"] { padding:0; border:none; background:transparent; width:100%; }
    button { margin-top:10px; padding:10px 14px; border:none; border-radius:12px; background:linear-gradient(135deg,#22c55e,#16a34a); color:#0b1020; font-weight:700; cursor:pointer; width:100%; }
    .muted { color:#94a3b8; font-size:14px; }
    .stream-meta { display:flex; gap:16px; align-items:center; margin-top:16px; padding:12px; border-radius:16px; border:1px solid rgba(148,163,184,0.18); background:rgba(15,23,42,0.75); }
    .stream-cover { width:96px; height:96px; border-radius:16px; background:linear-gradient(135deg, rgba(34,197,94,0.35), rgba(15,23,42,0.85)); border:1px solid rgba(255,255,255,0.08); display:flex; align-items:center; justify-content:center; overflow:hidden; flex-shrink:0; }
    .stream-cover.has-art { background:none; border-color:rgba(255,255,255,0.18); }
    .stream-cover img { width:100%; height:100%; object-fit:cover; display:none; }
    .stream-cover.has-art img { display:block; }
    .stream-info { flex:1; min-width:0; }
    .stream-title { font-size:1.15rem; font-weight:600; margin-bottom:4px; color:#f8fafc; }
    .stream-subtitle { color:#cbd5e1; font-size:0.95rem; line-height:1.4; }
    .channel-pill { display:inline-flex; align-items:center; font-size:0.65rem; letter-spacing:0.08em; text-transform:uppercase; padding:2px 10px; border-radius:999px; border:1px solid rgba(226,232,240,0.24); color:var(--channel-accent); background:rgba(15,23,42,0.9); margin-bottom:8px; }
  </style>
</head>
<body>
  <div class="panel">
    <h2 style="margin:0;">Web Node</h2>
    <p class="muted">This is experimental. It plays the Snapserver stream in your browser and registers as a node.</p>
    <div class="stream-meta" id="stream-meta">
      <div class="stream-cover" id="stream-cover">
        <img id="stream-art" alt="Stream artwork">
      </div>
      <div class="stream-info">
        <div class="channel-pill" id="channel-pill">Channel</div>
        <div class="stream-title" id="stream-title">No active stream</div>
        <div class="stream-subtitle" id="stream-subtitle">Start playback to show cover art and metadata.</div>
      </div>
    </div>
    <div id="register-block">
      <label>Node name</label>
      <input id="node-name" placeholder="Browser node">
      <button id="register">Start web node</button>
    </div>
    <button id="disconnect" style="width:100%; margin-top:10px; display:none; background:linear-gradient(135deg,#ef4444,#dc2626);">Disconnect</button>
    <div id="status" class="muted" style="margin-top:8px;">Idle</div>
    <div style="margin-top:8px;">
      <label>Node volume</label>
      <input id="node-volume" type="range" min="0" max="100" value="75" disabled>
    </div>
    <audio id="player" controls autoplay style="margin-top:12px; width:100%;" crossorigin="anonymous"></audio>
  </div>
  <script>
    const nameInput = document.getElementById('node-name');
    const registerBtn = document.getElementById('register');
    const disconnectBtn = document.getElementById('disconnect');
    const statusEl = document.getElementById('status');
    const audio = document.getElementById('player');
    const nodeVol = document.getElementById('node-volume');
    const registerBlock = document.getElementById('register-block');
    const streamTitle = document.getElementById('stream-title');
    const streamSubtitle = document.getElementById('stream-subtitle');
    const streamArt = document.getElementById('stream-art');
    const streamCover = document.getElementById('stream-cover');
    const channelPill = document.getElementById('channel-pill');

    let nodeId = null;
    let pc = null;
    let ws = null;
    let channelId = null;
    let channelSource = 'spotify';
    let channelName = '';
    let channelAccent = '#22c55e';
    let metadataTimer = null;
    let hasRenderedMetadata = false;

    function setStatus(message) {
      statusEl.textContent = message;
    }

    function wsUrl(id) {
      const proto = window.location.protocol === 'https:' ? 'wss://' : 'ws://';
      return `${proto}${window.location.host}/ws/web-node?node_id=${encodeURIComponent(id)}`;
    }

    async function waitForIce(connection, timeoutMs = 2500) {
      if (connection.iceGatheringState === 'complete') return;
      await new Promise(resolve => {
        const timer = setTimeout(() => {
          connection.removeEventListener('icegatheringstatechange', check);
          resolve();
        }, timeoutMs);
        function check() {
          if (connection.iceGatheringState === 'complete') {
            clearTimeout(timer);
            connection.removeEventListener('icegatheringstatechange', check);
            resolve();
          }
        }
        connection.addEventListener('icegatheringstatechange', check);
      });
    }

    async function startWebNode() {
      if (pc) {
        setStatus('Already connected. Disconnect first.');
        return;
      }
      registerBtn.disabled = true;
      setStatus('Connecting…');
      try {
        const name = nameInput.value.trim() || 'Browser node';
        pc = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });
        pc.ontrack = (event) => {
          const [stream] = event.streams;
          audio.srcObject = stream;
          audio.play().catch(() => {});
          nodeVol.disabled = false;
        };
        pc.onconnectionstatechange = () => {
          if (!pc) return;
          if (['disconnected', 'failed'].includes(pc.connectionState)) {
            setStatus('Connection lost');
            disconnect(false);
          }
        };

        const rawOffer = await pc.createOffer({ offerToReceiveAudio: true });
        const offer = {
          type: rawOffer.type,
          sdp: enhanceOpusSdp(rawOffer.sdp || '', 44100),
        };
        await pc.setLocalDescription(offer);
        await waitForIce(pc);

        const res = await fetch('/api/web-nodes/session', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            name,
            sdp: pc.localDescription?.sdp,
            type: pc.localDescription?.type,
          }),
        });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json();
        nodeId = data.node.id;
        channelId = data.node.channel_id || null;
        await pc.setRemoteDescription({ type: data.answer_type, sdp: data.answer });
        await connectControlSocket();
        await hydrateChannelDetails(channelId);
        startMetadataPolling();
        registerBlock.style.display = 'none';
        disconnectBtn.style.display = 'block';
        disconnectBtn.disabled = false;
        setStatus(`Connected as ${data.node.name}`);
      } catch (err) {
        console.error(err);
        setStatus(`Failed to connect: ${err.message}`);
        await cleanupLocal();
      } finally {
        registerBtn.disabled = false;
      }
    }

    async function connectControlSocket() {
      if (!nodeId) return;
      ws = new WebSocket(wsUrl(nodeId));
      ws.onmessage = (evt) => {
        try {
          const msg = JSON.parse(evt.data);
          handleControlMessage(msg);
        } catch (err) {
          console.warn('Invalid control message', err);
        }
      };
      ws.onclose = () => {
        if (nodeId) {
          setStatus('Control channel closed');
          disconnect(false);
        }
      };
    }

    function handleControlMessage(msg) {
      if (msg.type === 'volume') {
        const percent = Math.max(0, Math.min(100, msg.percent ?? 0));
        audio.volume = percent / 100;
        nodeVol.value = percent;
        setStatus(`Volume ${percent}%`);
      } else if (msg.type === 'mute') {
        audio.muted = !!msg.muted;
        setStatus(msg.muted ? 'Muted' : 'Playing');
      } else if (msg.type === 'session' && msg.state === 'ended') {
        setStatus('Session ended by controller');
        disconnect(false);
      }
    }

    async function disconnect(manual = true) {
      if (!nodeId) {
        await cleanupLocal();
        return;
      }
      disconnectBtn.disabled = true;
      try {
        if (manual) {
          await fetch(`/api/nodes/${nodeId}`, { method: 'DELETE' });
        }
      } catch (err) {
        console.warn('Failed to unregister node', err);
      } finally {
        await cleanupLocal();
        setStatus(manual ? 'Disconnected' : 'Idle');
      }
    }

    async function cleanupLocal() {
      if (ws) {
        ws.onclose = null;
        ws.close();
        ws = null;
      }
      if (pc) {
        pc.onconnectionstatechange = null;
        pc.getSenders().forEach(sender => sender.track?.stop());
        pc.close();
        pc = null;
      }
      nodeId = null;
      channelId = null;
      channelSource = 'spotify';
      channelName = '';
      applyChannelAccent('#22c55e');
      stopMetadataPolling();
      setDefaultMetadata();
      audio.pause();
      audio.srcObject = null;
      audio.currentTime = 0;
      nodeVol.disabled = true;
      nodeVol.value = 75;
      registerBlock.style.display = 'block';
      disconnectBtn.style.display = 'none';
    }

    function updateStreamDisplay(title, subtitle, artUrl, artAlt) {
      streamTitle.textContent = title || 'No active stream';
      streamSubtitle.textContent = subtitle || '';
      if (artUrl) {
        if (streamArt.src !== artUrl) {
          streamArt.src = artUrl;
        }
        streamArt.alt = artAlt || 'Cover art';
        streamCover.classList.add('has-art');
        streamCover.style.background = 'none';
      } else {
        streamArt.removeAttribute('src');
        streamArt.alt = '';
        streamCover.classList.remove('has-art');
        streamCover.style.background = buildAccentBackground();
      }
    }

    function setDefaultMetadata(message = 'Start playback to show cover art and metadata.') {
      hasRenderedMetadata = false;
      updateStreamDisplay(channelName || 'No active stream', message, null, '');
    }

    function renderMetadata(title, subtitle, artUrl, artAlt) {
      hasRenderedMetadata = true;
      updateStreamDisplay(title, subtitle, artUrl, artAlt);
    }

    function applyChannelAccent(color) {
      channelAccent = color || '#22c55e';
      if (channelPill) {
        channelPill.style.borderColor = channelAccent;
        channelPill.style.color = channelAccent;
      }
      if (!streamCover.classList.contains('has-art')) {
        streamCover.style.background = buildAccentBackground();
      }
    }

    function buildAccentBackground() {
      const fallback = 'rgba(34,197,94,0.35)';
      const converted = hexToRgba(channelAccent, 0.35);
      const start = converted || fallback;
      return `linear-gradient(135deg, ${start}, rgba(15,23,42,0.85))`;
    }

    function hexToRgba(hex, alpha = 1) {
      if (typeof hex !== 'string') return null;
      const trimmed = hex.replace('#', '').trim();
      if (!trimmed) return null;
      const normalized = trimmed.length === 3
        ? trimmed.split('').map(ch => ch + ch).join('')
        : trimmed;
      if (normalized.length !== 6) return null;
      const intVal = parseInt(normalized, 16);
      if (Number.isNaN(intVal)) return null;
      const r = (intVal >> 16) & 255;
      const g = (intVal >> 8) & 255;
      const b = intVal & 255;
      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    function updateChannelBadge() {
      if (!channelPill) return;
      if (channelName) {
        channelPill.textContent = channelName;
        channelPill.style.display = 'inline-flex';
      } else {
        channelPill.textContent = 'Channel';
        channelPill.style.display = 'none';
      }
    }

    async function hydrateChannelDetails(id) {
      if (!id) {
        channelSource = 'spotify';
        channelName = '';
        updateChannelBadge();
        setDefaultMetadata();
        return;
      }
      try {
        const res = await fetch('/api/channels');
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const payload = await res.json();
        const channels = Array.isArray(payload?.channels) ? payload.channels : [];
        const current = channels.find(entry => entry?.id === id);
        if (!current) {
          channelSource = 'spotify';
          channelName = '';
          updateChannelBadge();
          setDefaultMetadata('Channel not found');
          return;
        }
        channelSource = (current.source || 'spotify').toLowerCase();
        channelName = current.name || '';
        applyChannelAccent(current.color);
        updateChannelBadge();
        if (channelSource === 'radio') {
          renderRadioMetadata(current.radio_state || null, null);
        } else {
          setDefaultMetadata('Connected. Waiting for playback metadata.');
        }
      } catch (err) {
        console.warn('Failed to load channel info', err);
        if (!hasRenderedMetadata) {
          setDefaultMetadata('Unable to load channel configuration.');
        }
      }
    }

    function startMetadataPolling() {
      stopMetadataPolling();
      if (!channelId) return;
      fetchAndRenderMetadata();
      metadataTimer = setInterval(fetchAndRenderMetadata, 15000);
    }

    function stopMetadataPolling() {
      if (metadataTimer) {
        clearInterval(metadataTimer);
        metadataTimer = null;
      }
    }

    async function fetchAndRenderMetadata() {
      if (!channelId) return;
      try {
        if (channelSource === 'radio') await fetchRadioMetadata();
        else await fetchSpotifyMetadata();
      } catch (err) {
        console.warn('Metadata refresh failed', err);
        if (!hasRenderedMetadata) {
          setDefaultMetadata('Metadata unavailable.');
        }
      }
    }

    async function fetchSpotifyMetadata() {
      const url = `/api/spotify/player/status?channel_id=${encodeURIComponent(channelId)}`;
      const res = await fetch(url);
      if (!res.ok) throw new Error(`Spotify status ${res.status}`);
      const payload = await res.json();
      const rawItem = resolveSpotifyItem(payload);
      if (rawItem) {
        const title = rawItem.name || 'Unknown track';
        const artists = formatArtists(rawItem);
        const art = resolveArtUrl(rawItem);
        renderMetadata(title, artists || channelName || 'Spotify playback', art, rawItem.name ? `${rawItem.name} cover art` : 'Album art');
      } else if (!payload.active && payload.snapshot?.item) {
        const snapshotItem = payload.snapshot.item;
        const sub = formatArtists(snapshotItem) || 'Last played on this channel';
        renderMetadata(snapshotItem.name || channelName || 'Recent track', sub, resolveArtUrl(snapshotItem), snapshotItem.name ? `${snapshotItem.name} cover art` : 'Album art');
      } else {
        setDefaultMetadata('No Spotify playback detected.');
      }
    }

    function resolveSpotifyItem(payload) {
      if (payload?.item && typeof payload.item === 'object') {
        return payload.item;
      }
      if (payload?.snapshot?.item && typeof payload.snapshot.item === 'object') {
        return payload.snapshot.item;
      }
      return null;
    }

    function formatArtists(item) {
      if (Array.isArray(item?.artists)) {
        return item.artists.map(artist => artist?.name).filter(Boolean).join(', ');
      }
      if (typeof item?.artists === 'string') return item.artists;
      return '';
    }

    function resolveArtUrl(item) {
      const images = item?.album?.images;
      if (Array.isArray(images) && images.length) {
        const sorted = images.slice().sort((a, b) => (Math.abs((a?.height || 0) - 200) - Math.abs((b?.height || 0) - 200)));
        return sorted[0]?.url || null;
      }
      return null;
    }

    async function fetchRadioMetadata() {
      const res = await fetch(`/api/radio/status/${encodeURIComponent(channelId)}`);
      if (!res.ok) throw new Error(`Radio status ${res.status}`);
      const payload = await res.json();
      renderRadioMetadata(payload?.radio_state || null, payload?.runtime || null);
    }

    function renderRadioMetadata(state, runtime) {
      const radioState = state && typeof state === 'object' ? state : {};
      const runtimeMeta = runtime?.metadata && typeof runtime.metadata === 'object' ? runtime.metadata : {};
      const storedMeta = radioState.last_metadata && typeof radioState.last_metadata === 'object' ? radioState.last_metadata : {};
      const metadata = { ...storedMeta, ...runtimeMeta };
      const stationSet = Boolean(radioState.stream_url);
      const title = radioState.station_name || channelName || 'Radio channel';
      if (!stationSet) {
        renderMetadata(title, 'Tune a station to start radio playback.', radioState.station_favicon || null, `${title} artwork`);
        return;
      }
      let subtitle = '';
      if (metadata.artist || metadata.title) {
        subtitle = [metadata.artist, metadata.title].filter(Boolean).join(' – ');
      } else if (metadata.streamTitle || metadata.StreamTitle) {
        subtitle = metadata.streamTitle || metadata.StreamTitle;
      } else if (metadata.text) {
        subtitle = metadata.text;
      }
      if (!subtitle) {
        const detailParts = [];
        if (radioState.station_country) detailParts.push(radioState.station_country);
        if (radioState.bitrate) detailParts.push(`${radioState.bitrate} kbps`);
        if (runtime?.message) detailParts.push(runtime.message);
        subtitle = detailParts.join(' • ') || 'Live radio';
      }
      if (radioState.playback_enabled === false) {
        subtitle = 'Radio playback stopped';
      }
      const artwork = metadata.art_url || metadata.artwork || radioState.station_favicon || null;
      renderMetadata(title, subtitle, artwork, title ? `${title} artwork` : 'Station artwork');
    }

    function enhanceOpusSdp(sdp, sampleRate = 44100) {
      if (!sdp) return sdp;
      const lines = sdp.split(/\r?\n/);
      const opusIndex = lines.findIndex(line => line.startsWith('a=rtpmap:') && line.toLowerCase().includes('opus/48000'));
      if (opusIndex === -1) {
        return sdp;
      }
      const rtpmapParts = lines[opusIndex].split(/\s+/);
      const payloadType = (rtpmapParts[0]?.split(':')[1]) || null;
      if (!payloadType) {
        return sdp;
      }
      if (!/opus\/48000\/2/i.test(lines[opusIndex])) {
        lines[opusIndex] = lines[opusIndex].replace(/opus\/48000(?!\/2)/i, 'opus/48000/2');
      }
      const desiredParams = {
        stereo: '1',
        'sprop-stereo': '1',
        maxaveragebitrate: '256000',
        maxplaybackrate: String(sampleRate),
        ptime: '20',
        minptime: '10',
        useinbandfec: '1',
      };
      const fmtpPrefix = `a=fmtp:${payloadType}`;
      const fmtpIndex = lines.findIndex(line => line.startsWith(fmtpPrefix));
      if (fmtpIndex === -1) {
        const serialized = Object.entries(desiredParams).map(([key, value]) => `${key}=${value}`).join(';');
        lines.splice(opusIndex + 1, 0, `${fmtpPrefix} ${serialized}`);
      } else {
        const existing = lines[fmtpIndex].slice(fmtpPrefix.length).trim().replace(/^\s+/, '');
        const currentParams = {};
        if (existing) {
          existing.split(';').forEach(part => {
            const segment = part.trim();
            if (!segment) return;
            const [key, value = '1'] = segment.split('=');
            currentParams[key] = value;
          });
        }
        Object.assign(currentParams, desiredParams);
        const serialized = Object.entries(currentParams).map(([key, value]) => `${key}=${value}`).join(';');
        lines[fmtpIndex] = `${fmtpPrefix} ${serialized}`;
      }
      return lines.join('\r\n');
    }

    registerBtn.addEventListener('click', startWebNode);
    disconnectBtn.addEventListener('click', () => disconnect(true));
    nodeVol.addEventListener('input', () => { audio.volume = nodeVol.value / 100; });
    setDefaultMetadata();
    updateChannelBadge();
  </script>
</body>
</html>
